<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="BTsn7G4z0tDjeOH1b33WmkD_OVP92D_aBbbyqUG_1Vo">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":-1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="今天的总结：">
<meta property="og:type" content="article">
<meta property="og:title" content="每日总结">
<meta property="og:url" content="http://yoursite.com/2019/10/10/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="惊蛰">
<meta property="og:description" content="今天的总结：">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://raw.githubusercontent.com/Pipepw/FigureBed/master/blog_files/img/PicGo-Github-PicBed/image-20200513214347418-1589673951207.png">
<meta property="og:image" content="e:%5Chexo%5Csource%5C_posts%5C%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93.assets%5C20200517085619.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Pipepw/FigureBed/master/blog_files/img/PicGo-Github-PicBed/image-20200419121358719.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Pipepw/FigureBed/master/blog_files/img/PicGo-Github-PicBed/image-20200403095111668.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Pipepw/FigureBed/master/blog_files/img/PicGo-Github-PicBed/image-20200401115558796.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Pipepw/FigureBed/master/blog_files/img/PicGo-Github-PicBed/image-20200401115656369.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Pipepw/FigureBed/master/blog_files/img/PicGo-Github-PicBed/image-20200401120204988.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Pipepw/FigureBed/master/blog_files/img/PicGo-Github-PicBed/image-20200401151607471.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Pipepw/FigureBed/master/blog_files/img/PicGo-Github-PicBed/image-20200330235849036.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Pipepw/FigureBed/master/blog_files/img/PicGo-Github-PicBed/image-20200330235925998.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Pipepw/FigureBed/master/blog_files/img/PicGo-Github-PicBed/image-20200331000938202.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Pipepw/FigureBed/master/blog_files/img/PicGo-Github-PicBed/image-20200329100135825.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Pipepw/FigureBed/master/blog_files/img/PicGo-Github-PicBed/image-20200517083546073.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Pipepw/FigureBed/master/blog_files/img/PicGo-Github-PicBed/image-20200316231310632.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Pipepw/FigureBed/master/blog_files/img/PicGo-Github-PicBed/image-20200310181437823.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Pipepw/FigureBed/master/blog_files/img/PicGo-Github-PicBed/image-20200517083704948.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Pipepw/FigureBed/master/blog_files/img/PicGo-Github-PicBed/image-20200225001215839.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Pipepw/FigureBed/master/blog_files/img/PicGo-Github-PicBed/image-20200225001250427.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Pipepw/FigureBed/master/blog_files/img/PicGo-Github-PicBed/image-20200225001331213.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Pipepw/FigureBed/master/blog_files/img/PicGo-Github-PicBed/image-20200225001435048.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Pipepw/FigureBed/master/blog_files/img/PicGo-Github-PicBed/image-20200225001824915.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Pipepw/FigureBed/master/blog_files/img/PicGo-Github-PicBed/image-20200225001859867.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Pipepw/FigureBed/master/blog_files/img/PicGo-Github-PicBed/image-20200225002014047.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Pipepw/FigureBed/master/blog_files/img/PicGo-Github-PicBed/image-20200225002350927.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Pipepw/FigureBed/master/blog_files/img/PicGo-Github-PicBed/image-20200220111255446.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Pipepw/FigureBed/master/blog_files/img/PicGo-Github-PicBed/image-20200207093716856.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Pipepw/FigureBed/master/blog_files/img/PicGo-Github-PicBed/image-20200201100642716.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Pipepw/FigureBed/master/blog_files/img/PicGo-Github-PicBed/image-20200119161922005.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Pipepw/FigureBed/master/blog_files/img/PicGo-Github-PicBed/image-20200119163018574.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Pipepw/FigureBed/master/blog_files/img/PicGo-Github-PicBed/image-20200119173202248.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Pipepw/FigureBed/master/blog_files/img/PicGo-Github-PicBed/image-20200119173206767.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Pipepw/FigureBed/master/blog_files/img/PicGo-Github-PicBed/image-20200118151933428.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Pipepw/FigureBed/master/blog_files/img/PicGo-Github-PicBed/image-20200118151953483.png">
<meta property="og:image" content="e:%5Chexo%5Csource%5C_posts%5C%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93.assets%5C20200517085407.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Pipepw/FigureBed/master/blog_files/img/PicGo-Github-PicBed/image-20200117214049384.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Pipepw/FigureBed/master/blog_files/img/PicGo-Github-PicBed/image-20200117214213004.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Pipepw/FigureBed/master/blog_files/img/PicGo-Github-PicBed/image-20200112093334695.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Pipepw/FigureBed/master/blog_files/img/PicGo-Github-PicBed/image-20200111203149432.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Pipepw/FigureBed/master/blog_files/img/PicGo-Github-PicBed/image-20200111203156508.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Pipepw/FigureBed/master/blog_files/img/PicGo-Github-PicBed/image-20200111203214750.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Pipepw/FigureBed/master/blog_files/img/PicGo-Github-PicBed/image-20200111203218824.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Pipepw/FigureBed/master/blog_files/img/PicGo-Github-PicBed/image-20191213000458183.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Pipepw/FigureBed/master/blog_files/img/PicGo-Github-PicBed/image-20191213000627934.png">
<meta property="article:published_time" content="2019-10-10T13:28:51.380Z">
<meta property="article:modified_time" content="2020-05-17T01:13:25.781Z">
<meta property="article:author" content="Pipepw">
<meta property="article:tag" content="无">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/Pipepw/FigureBed/master/blog_files/img/PicGo-Github-PicBed/image-20200513214347418-1589673951207.png">

<link rel="canonical" href="http://yoursite.com/2019/10/10/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>每日总结 | 惊蛰</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">惊蛰</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/10/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="Pipepw">
      <meta itemprop="description" content="朝乾夕惕">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="惊蛰">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          每日总结
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-10-10 21:28:51" itemprop="dateCreated datePublished" datetime="2019-10-10T21:28:51+08:00">2019-10-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-05-17 09:13:25" itemprop="dateModified" datetime="2020-05-17T09:13:25+08:00">2020-05-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%97%A0/" itemprop="url" rel="index"><span itemprop="name">无</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>今天的总结：</p>
<a id="more"></a>











<h1 id="05-16"><a href="#05-16" class="headerlink" title="05/16:"></a>05/16:</h1><h3 id="关键字：单链表反转、查找Spring的配置、ORM、Android软键盘的显示与隐藏、工厂策略、加快IDEA导入包的速度、控制反转、好用的作图网站、学习设计模式、DI与IoC、使用Spring创建对象、使用ApplicationContext获取对象、Spring的三种装配Bean的方式、Spring-Bean的手动装配、Spring-Bean的自动装配、注解、使用Java配置Spring-Bean、marginBottom和marginRight设置之后无效、代理模式、alpha、撤销commit、git-pull"><a href="#关键字：单链表反转、查找Spring的配置、ORM、Android软键盘的显示与隐藏、工厂策略、加快IDEA导入包的速度、控制反转、好用的作图网站、学习设计模式、DI与IoC、使用Spring创建对象、使用ApplicationContext获取对象、Spring的三种装配Bean的方式、Spring-Bean的手动装配、Spring-Bean的自动装配、注解、使用Java配置Spring-Bean、marginBottom和marginRight设置之后无效、代理模式、alpha、撤销commit、git-pull" class="headerlink" title="关键字：单链表反转、查找Spring的配置、ORM、Android软键盘的显示与隐藏、工厂策略、加快IDEA导入包的速度、控制反转、好用的作图网站、学习设计模式、DI与IoC、使用Spring创建对象、使用ApplicationContext获取对象、Spring的三种装配Bean的方式、Spring Bean的手动装配、Spring Bean的自动装配、注解、使用Java配置Spring Bean、marginBottom和marginRight设置之后无效、代理模式、alpha、撤销commit、git pull"></a>关键字：单链表反转、查找Spring的配置、ORM、Android软键盘的显示与隐藏、工厂策略、加快IDEA导入包的速度、控制反转、好用的作图网站、学习设计模式、DI与IoC、使用Spring创建对象、使用ApplicationContext获取对象、Spring的三种装配Bean的方式、Spring Bean的手动装配、Spring Bean的自动装配、注解、使用Java配置Spring Bean、marginBottom和marginRight设置之后无效、代理模式、alpha、撤销commit、git pull</h3><ol>
<li><p>单链表反转：</p>
<ul>
<li><p>递归：</p>
<p>只需要交换当前两个节点的指向就行了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ListNode * ReverseList(ListNode * head)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//递归终止条件：找到链表最后一个结点</span></span><br><span class="line">	<span class="keyword">if</span> (head == NULL || head-&gt;next == NULL)</span><br><span class="line">		<span class="keyword">return</span> head;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		ListNode * newhead = ReverseList(head-&gt;next);<span class="comment">//先反转后面的链表，从最后面的两个结点开始反转，依次向前</span></span><br><span class="line">		head-&gt;next-&gt;next = head;<span class="comment">//将后一个链表结点指向前一个结点</span></span><br><span class="line">		head-&gt;next = NULL;<span class="comment">//将原链表中前一个结点指向后一个结点的指向关系断开</span></span><br><span class="line">		<span class="keyword">return</span> newhead;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ol>
<ul>
<li><p>非递归：</p>
<p>用一个指针按照顺序交换两个节点的指向就行了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ListNode* reverseList2(ListNode* head) &#123;</span><br><span class="line">	<span class="keyword">if</span> (head == NULL || head-&gt;next == NULL) </span><br><span class="line">		<span class="keyword">return</span> head;</span><br><span class="line">	ListNode* prev = head;</span><br><span class="line">	ListNode* cur = head-&gt;next;</span><br><span class="line">	ListNode* temp = head-&gt;next-&gt;next;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">while</span> (cur)&#123;</span><br><span class="line">		temp = cur-&gt;next; <span class="comment">//temp作为中间节点，记录当前结点的下一个节点的位置</span></span><br><span class="line">		cur-&gt;next = prev;  <span class="comment">//当前结点指向前一个节点</span></span><br><span class="line">		prev = cur;     <span class="comment">//指针后移</span></span><br><span class="line">		cur = temp;  <span class="comment">//指针后移，处理下一个节点</span></span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	head-&gt;next = NULL; <span class="comment">//while结束后，将翻转后的最后一个节点（即翻转前的第一个结点head）的链域置为NULL</span></span><br><span class="line">	<span class="keyword">return</span> prev;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<ol start="2">
<li><p>查找Spring的配置：</p>
<p>在Spring mven的官网，可以找到相关的Spring配置方式</p>
</li>
<li><p>ORM：</p>
<p>ORM就是对象关系映射，将2Java中的对象与数据库中的表对应起来。而Spring ORM就是对两种ORM技术提供支持，hibernate5和jpa，hibernate5是一个ORM框架，jpa是java持久化api</p>
</li>
<li><p>Android软键盘的显示与隐藏：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">InputMethodManager imm = (InputMethodManager) activity.getSystemService(Context.INPUT_METHOD_SERVICE);</span><br><span class="line"><span class="comment">//显示软键盘：</span></span><br><span class="line">imm.showSoftInput(activity.getWindow().getDecorView(),InputMethodManager.SHOW_FORCED);</span><br><span class="line"><span class="comment">//关闭软键盘： </span></span><br><span class="line">imm.hideSoftInputFromWindow(activity.getCurrentFocus().getWindowToken(), <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>工厂策略：</p>
<p>工厂就是把生成对象的工作提取出来，放到工厂里面<br>抽象工厂就是一个类对应一个工厂</p>
</li>
<li><p>加快IDEA导入包的速度：</p>
<p>使用阿里云镜像导入包使用阿里云镜像导入包</p>
</li>
<li><p>控制反转：</p>
<ul>
<li><p>之前的操作：</p>
<p>需要什么的时候，在程序中进行修改创建对象的地方，每当用户需要的对象发生改变时，就需要重新创建对象，使用与创建之间存在依赖关系</p>
</li>
<li><p>之后的操作：</p>
<p>将创建对象的操作交给第三方来完成，用户调用第三方的set方法就可以将需要的对象传入到使用的地方，而不需要对程序进行修改</p>
</li>
<li><p>IoC：</p>
<p>当使用Spring作为第三方时，就是Spring IoC容器了</p>
</li>
</ul>
</li>
<li><p>好用的作图网站：</p>
<p>processon</p>
</li>
<li><p>学习设计模式：</p>
<p>要在脑海中想一下在代码中会怎样实现，这样才能更好的掌握</p>
</li>
<li><p>DI与IoC：</p>
<p>DI（依赖注入）是实现IOC（控制反转）的一种方式</p>
</li>
<li><p>使用Spring创建对象：</p>
<p>如果使用Spring创建对象，也就是xml的bean来创建对象，那么就需要创建一个类，里面有对应的注入方法，最后还是通过注解的方式来注入的</p>
</li>
<li><p>使用ApplicationContext获取对象：</p>
<p><img src="https://raw.githubusercontent.com/Pipepw/FigureBed/master/blog_files/img/PicGo-Github-PicBed/image-20200513214347418-1589673951207.png" alt="image-20200513214347418"></p>
<p>在创建ApplicationContext的时候，Spring容器中的所有对象都被创建了</p>
</li>
<li><p>Spring的三种装配Bean的方式：</p>
<ul>
<li>在xml中显式配置</li>
<li>在java中显式配置</li>
<li>隐式的自动装配</li>
</ul>
</li>
<li><p>Spring Bean的手动装配：</p>
<p><img src="E:%5Chexo%5Csource%5C_posts%5C%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93.assets%5C20200517085619.png" alt=""></p>
<p>在xml配置文件中进行修改</p>
</li>
<li><p>Spring Bean的自动装配：</p>
<ul>
<li>在程序中根据上下文自动寻找，并自动给bean装配属性</li>
<li>在xml中使用autowired关键字自动装配，就不用给类中的每一个变量赋值了</li>
<li>在Java中需要注入类的地方使用@Autwired注解自动装配，这样可以忽略Set方法（xml自动装配还需要创建Set方法）</li>
</ul>
</li>
<li><p>注解：</p>
<ul>
<li>@Nullable注解表示这个字段可以为空</li>
<li>@Autowired(require = false)表示这个对象可以为null</li>
<li>@Autowired先使用byType，找不到时再使用byName来查找类，如果两个都找不到时，需要使用</li>
<li>@Qualifier可以指向这个对象的值 ，就可以使用@Qualifier(value=”name”)来指定<br>使用</li>
<li>@Resource也可以达到自动装配的目的和@Autowired的效果是一样的，不过可以直接通过@Resource(name=”name”)来指定具体的对象，这样来看，@Resource要好用一些啊</li>
</ul>
</li>
<li><p>使用Java配置Spring Bean：（完全不需要xml）</p>
<ul>
<li>使用@Configuration注解表示这是一个配置类</li>
<li>使用@Bean来创建Bean，表示这个对象放到了Spring容器中</li>
<li>使用对象的方法与xml不同：使用AnnotationConfigApplicationContext来获取配置文件</li>
</ul>
</li>
<li><p>marginBottom和marginRight设置之后无效：</p>
<ol>
<li>解决方法是在下面放一个没有东西的textView，设置属性layout_alignParentBottom=”true”将其放到底部</li>
<li>然后使用layout_above将控件放在那个TextView上面，从而达到同样的效果</li>
</ol>
</li>
<li><p>使用margin可以为负数，这样就可以将控件放到屏幕外面了</p>
</li>
<li><p>代理模式：</p>
<ul>
<li><p>好处：</p>
<ol>
<li>每个角色的工作更纯粹，不用关注公共事务</li>
<li>公共事务交给代理角色来做，实现业务分工</li>
<li>公共事务发生扩展的时候，方便集中管理（这里就是AOP中的内容了吧，所以学AOP之前要先学代理模式）</li>
</ol>
</li>
<li><p>坏处：</p>
<p>一个真实角色就会产生一个代理角色，是代码量增加，开发效率降低（SpringAOP应该会解决这个问题）</p>
</li>
</ul>
</li>
<li><p>alpha：</p>
<p>animator动画中透明度属性，0f表示透明，1f表示完全不透明</p>
</li>
<li><p>撤销commit：</p>
<ul>
<li><p>git reset –soft HEAD~1撤销上一次的提交<br>1可以改为其他数字，表示撤销前面提交的次数</p>
</li>
<li><p>其他参数：</p>
<ol>
<li><p>–mixed （不修改代码，撤销commit以及add）<br>意思是：不删除工作空间改动代码，撤销commit，并且撤销git add . 操作<br>这个为默认参数,git reset –mixed HEAD^ 和 git reset HEAD^ 效果是一样的。</p>
</li>
<li><p>–soft （不修改代码，只撤销commit）<br>不删除工作空间改动代码，撤销commit，不撤销git add . </p>
</li>
<li><p>–hard(会修改代码)</p>
<p>删除工作空间改动代码，撤销commit，撤销git add . </p>
<p>注意完成这个操作后，就恢复到了上一次的commit状态。</p>
</li>
</ol>
</li>
<li><p>只想修改commit的注释：</p>
<p>git commit –amend</p>
</li>
</ul>
</li>
<li><p>git pull：</p>
<p>先commit再pull然后再push</p>
</li>
</ol>
<hr>
<h1 id="05-12"><a href="#05-12" class="headerlink" title="05/12:"></a>05/12:</h1><h3 id="关键字：工厂模式、Spring-Dao中的一般操作、Spring-bean、持久层、业务层、控制反转、三种注入方式、反射、哑节点、leetcode会保存全局变量的值、汇编中的立即数、汇编的乘除法、汇编打断点、汇编器的使用方式、Android，animator动画的使用"><a href="#关键字：工厂模式、Spring-Dao中的一般操作、Spring-bean、持久层、业务层、控制反转、三种注入方式、反射、哑节点、leetcode会保存全局变量的值、汇编中的立即数、汇编的乘除法、汇编打断点、汇编器的使用方式、Android，animator动画的使用" class="headerlink" title="关键字：工厂模式、Spring Dao中的一般操作、Spring bean、持久层、业务层、控制反转、三种注入方式、反射、哑节点、leetcode会保存全局变量的值、汇编中的立即数、汇编的乘除法、汇编打断点、汇编器的使用方式、Android，animator动画的使用"></a>关键字：工厂模式、Spring Dao中的一般操作、Spring bean、持久层、业务层、控制反转、三种注入方式、反射、哑节点、leetcode会保存全局变量的值、汇编中的立即数、汇编的乘除法、汇编打断点、汇编器的使用方式、Android，animator动画的使用</h3><ol>
<li><p>工厂模式：</p>
<p>框架是有一个抽象产品类，抽象工厂类，以及两者的具体实现类，这样就可以在工厂中调用抽象产品类的方法，而不用关心具体实现了，只需要在传入的时候，传入具体的实现类，这样可以很好的进行扩展</p>
</li>
<li><p>Spring Dao中的一般操作：</p>
<p>定义对数据库的操作，使用jdbc的方法调用，在回调函数中将数据放到实体类中，args中存放的是“？”参数占位符的参数。在使用之前，还需要将Spring Dao与数据库绑定起来</p>
</li>
<li><p>Spring bean：</p>
<p>将大多数应用程序逻辑代码都将放到Spring bean中</p>
</li>
<li><p>持久层：</p>
<ol>
<li>创建领域对象（也就是数据实体类）</li>
<li>创建Dao，用来处理与数据库相关的操作。将SQL语句定义为String类型，具体的使用照书上就行</li>
<li>在Spring中装配Dao，这个是在resources文件夹下创建一个Spring配置文件，也就是说，Spring的配置是在另一个文件中的，与pom.xml是分开的，这个照着书上做就行了</li>
</ol>
</li>
<li><p>业务层：</p>
<p>就是各个工作的集合，调用的地方，在Spring中配置Service也是在刚才的那个文件中</p>
</li>
<li><p>控制反转：</p>
<p>将某一接口具体实现类的控制权从调用类移除，转交给第三方决定，即由Spring容器借由Bean配置来进行控制，后来用依赖注入来替代控制反转这个概念，即让调用类对某一接口实现类的依赖关系由第三方（容器或协作类）注入，以移除调用类对某一接口实现类的依赖</p>
</li>
<li><p>三种注入方式：</p>
<p>构造函数注入，属性注入，接口注入</p>
<ol>
<li>构造函数注入：通过向构造函数传递参数来实现注入操作</li>
<li>属性注入：通过setter方法赋值来实现注入操作</li>
<li>接口注入：将需要注入的方法抽取到一个接口中，调用类通过实现接口相应的方法来实现注入操作。这种方法和属性注入的区别不大，并且需要额外声明接口，增加复杂度，所以一般不用这个注入方法</li>
</ol>
</li>
<li><p>反射：</p>
<p>接口注入就是将需要注入的方法抽取到一个接口中，调用类通过实现接口相应的方法来实现注入操作。这种方法和属性注入的区别不大，并且需要额外声明接口，增加复杂度，所以一般不用这个注入方法</p>
</li>
<li><p>哑节点：</p>
<p>java没有指针，所以需要一个哑节点指向头节点，这样就达到了指针的效果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);	<span class="comment">//哑节点</span></span><br><span class="line">dummy.next = head;</span><br><span class="line">ListNode first = dummy;</span><br><span class="line">ListNode second = dummy;</span><br></pre></td></tr></table></figure>
</li>
<li><p>leetcode会保存全局变量的值：</p>
<p>所以全局变量只在外面进行声明，赋值操作放到方法中执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; ans;	<span class="comment">//分成两个部分</span></span><br><span class="line">ans = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br></pre></td></tr></table></figure>
</li>
<li><p>汇编中的立即数：</p>
<p>默认是10进制</p>
</li>
<li><p>汇编的乘除法：</p>
<ol>
<li>共同点：<ol>
<li>另一个操作数都是在AL中</li>
<li>结果都是保存在AX中</li>
</ol>
</li>
<li>除法的结果AH中保存余数，AL中保存商</li>
</ol>
</li>
<li><p>汇编打断点：</p>
<p>在debug模式下，使用g=地址1 地址2 .。。其中地址1是开始地址，地址2则是断点地址，都是ip的值</p>
</li>
<li><p>汇编器的使用方式：</p>
<p>先使用masm编译，然后使用link链接，之后可以运行可执行文件或者使用debug的方式运行<br>debug中使用g打断点，使用t单步执行，使用u查看反编译内容</p>
</li>
<li><p>Android，animator动画的使用：（可用于各种控件）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义方式以及距离</span></span><br><span class="line">ObjectAnimator animatorYldy = ObjectAnimator.ofFloat(aireedy,<span class="string">"translationY"</span>,<span class="number">0f</span>,<span class="number">300f</span>);</span><br><span class="line">ObjectAnimator animatorRotateldy = ObjectAnimator.ofFloat(aireedy,<span class="string">"rotation"</span>,<span class="number">0f</span>,<span class="number">180f</span>);</span><br><span class="line"><span class="comment">// animatorYldy.setRepeatCount(x);	设置重复次数，-1表示一直重复，不过只能用于单独的动画</span></span><br><span class="line"><span class="comment">// animatorYldy.setStartDely(1000);	设置动画开始的延迟</span></span><br><span class="line">AnimatorSet set = <span class="keyword">new</span> AnimatorSet();</span><br><span class="line">set.setDuration(<span class="number">3000</span>);	<span class="comment">//设置动画的时间，可在动画单独设置</span></span><br><span class="line">set.play(animatorYldy).with(animatorRotateldy);	</span><br><span class="line"><span class="comment">//设置动画的执行，with表示一起执行，before表示之后执行（在之前），after在之前执行</span></span><br><span class="line"><span class="comment">//after---play(with)---before</span></span><br><span class="line"><span class="comment">//最多只能控制三个动画的执行顺序，如果有更多的动画，那么需要自行设置动画的延迟</span></span><br><span class="line">set.addListener(<span class="keyword">new</span> Animator.AnimatorListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationStart</span><span class="params">(Animator animator)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationEnd</span><span class="params">(Animator animator)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        animator.start();	<span class="comment">//加上这个就可以让系列动画重复执行了，可以添加变量控制执行次数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationCancel</span><span class="params">(Animator animator)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationRepeat</span><span class="params">(Animator animator)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">set.start();</span><br></pre></td></tr></table></figure>



</li>
</ol>
<hr>
<h1 id="04-26"><a href="#04-26" class="headerlink" title="04/26:"></a>04/26:</h1><h3 id="关键字：启动Android模拟器出错、Android-让图片不拉伸的方法"><a href="#关键字：启动Android模拟器出错、Android-让图片不拉伸的方法" class="headerlink" title="关键字：启动Android模拟器出错、Android 让图片不拉伸的方法"></a>关键字：启动Android模拟器出错、Android 让图片不拉伸的方法</h3><ol>
<li><p>启动Android模拟器出错：</p>
<ol>
<li>出现错误：error while loading state for instance 0x0 of device ‘goldfish_pipe’</li>
<li>解决方法，更新HAXM，<a href="https://github.com/intel/haxm" target="_blank" rel="noopener">https://github.com/intel/haxm</a></li>
</ol>
</li>
<li><p>Android 让图片不拉伸的方法：</p>
<p>在xml中加上这两个属性</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">android:adjustViewBounds="true"	表示保持比例不变</span><br><span class="line">android:scaleType="fitStart"	表示对齐左上角放大</span><br></pre></td></tr></table></figure>

</li>
</ol>
<hr>
<h1 id="04-18"><a href="#04-18" class="headerlink" title="04/18:"></a>04/18:</h1><h3 id="超算有延期了，不过有段时间没有做了"><a href="#超算有延期了，不过有段时间没有做了" class="headerlink" title="超算有延期了，不过有段时间没有做了"></a>超算有延期了，不过有段时间没有做了</h3><h3 id="关键字：Git从暂存区恢复、避免每次提交都输入用户和密码、使用git-cz出现错误、进程的内存空间、程序计数器、实现进程、进程与线程、进程间通信（三方面内容）、解决依赖的方法、实现临界区的一些方法、使用hex上传的方法、LeetCode正则表达式匹配的-回溯算法-、git协同工作的一般步骤"><a href="#关键字：Git从暂存区恢复、避免每次提交都输入用户和密码、使用git-cz出现错误、进程的内存空间、程序计数器、实现进程、进程与线程、进程间通信（三方面内容）、解决依赖的方法、实现临界区的一些方法、使用hex上传的方法、LeetCode正则表达式匹配的-回溯算法-、git协同工作的一般步骤" class="headerlink" title="关键字：Git从暂存区恢复、避免每次提交都输入用户和密码、使用git-cz出现错误、进程的内存空间、程序计数器、实现进程、进程与线程、进程间通信（三方面内容）、解决依赖的方法、实现临界区的一些方法、使用hex上传的方法、LeetCode正则表达式匹配的==回溯算法==、git协同工作的一般步骤"></a>关键字：Git从暂存区恢复、避免每次提交都输入用户和密码、使用git-cz出现错误、进程的内存空间、程序计数器、实现进程、进程与线程、进程间通信（三方面内容）、解决依赖的方法、实现临界区的一些方法、使用hex上传的方法、LeetCode正则表达式匹配的==回溯算法==、git协同工作的一般步骤</h3><ol>
<li><p>Git从暂存区恢复：</p>
<ol>
<li>如果是恢复文件的内容但是文件还在，那么使用 git checkout – 文件名就没问题</li>
<li>如果是恢复删除的文件，那么需要先使用 git restore –staged 文件名<br>然后使用 git restore 文件名进行恢复</li>
<li>如果是删除文件，那么直接在本地删除，然后提交就行了</li>
</ol>
</li>
<li><p>避免每次提交都输入用户和密码</p>
<ol>
<li><p>修改为SSH登录</p>
<p>如果版本库已经用https方式创建好了，你们就需要吸纳删除原来的提交方式</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote rm origin</span><br><span class="line">git remote add origin git@github.com:(用户名)/版本库名</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加ssh免密登录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;邮箱&quot;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>使用git-cz出现错误</p>
<ol>
<li>错误信息：The config file at “C:\Users\Pipe.czrc” contains invalid charset, expect utf8</li>
<li>解决方法：把.czrc删掉，用vscode重新写入{“path”:”cz-conventional-changelog”}就行了</li>
</ol>
</li>
<li><p>进程的内存空间</p>
<ol>
<li>分为三个部分：代码段、数据段和栈段</li>
<li>代码段的大小保持不变</li>
<li>数据段从下往上增长</li>
<li>栈段从上往下增长</li>
<li><img src="https://raw.githubusercontent.com/Pipepw/FigureBed/master/blog_files/img/PicGo-Github-PicBed/image-20200419121358719.png" alt="image-20200419121358719"></li>
</ol>
</li>
<li><p>程序计数器</p>
<p>每个进程都有一个程序计数器，在进程活跃的时候复制到物理计数器，不活跃的时候再复制回来</p>
</li>
<li><p>实现进程</p>
<p>通过操作系统维持一个进程表，表中存放进程的状态这样就可以快速启动进程</p>
</li>
<li><p>进程与线程</p>
<ol>
<li>每个进程中值存在一个地址空间和要给控制流。而线程则是在相同的地址空间中有多个控制流并行地运行</li>
<li>线程也有线程表</li>
</ol>
</li>
<li><p>进程间通信（三方面内容）</p>
<ol>
<li>一方面是传输数据</li>
<li>另一方面是存在竞争关系，即都需要某一物理资源</li>
<li>有一方面是存在依赖关系，比如同时读写同一寄存器等</li>
</ol>
</li>
<li><p>解决依赖的方法</p>
<ol>
<li>划分临界区</li>
<li>关键是任何两个进程不能同时处理临界区，还有不能一直等待临界区空闲，不能一直在临界区中</li>
<li>临界区就是进程的一些共享资源</li>
</ol>
</li>
<li><p>实现临界区的一些方法</p>
<ol>
<li>关闭中断：因为CPU只有在发生时钟或其他中断时才会进行进程切换，没有进程切换，自然就不会出现问题了</li>
<li>锁变量：这个就是加锁了，不过问题时对这个锁变量的处理也有可能会出现问题</li>
<li>严格交替法：进程按照顺序访问临界区</li>
<li>Peterson解决方案</li>
<li>TSL指令，这个不就是CPU中的一个专门为进程设置的寄存器吗关闭中断：因为CPU只有在发生时钟或其他中断时才会进行进程切换，没有进程切换，自然就不会出现问题了锁变量：这个就是加锁了，不过问题时对这个锁变量的处理也有可能会出现问题严格交替法：进程按照顺序访问临界区Peterson解决方案TSL指令，这个不就是CPU中的一个专门为进程设置的寄存器吗</li>
</ol>
</li>
<li><p>使用hex上传的方法</p>
<p>命令行进入到hexo的目录，然后使用hexo clean清除缓存，使用hexo g 生成页面，hexo server在本地预览，最后使用 hexo d提交</p>
</li>
<li><p>LeetCode正则表达式匹配的==回溯算法==</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String text, String pattern)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pattern.isEmpty()) <span class="keyword">return</span> text.isEmpty();</span><br><span class="line">        <span class="comment">//思想就是只看第一个字符，然后向后移动</span></span><br><span class="line">        <span class="keyword">boolean</span> first_match = (!text.isEmpty() &amp;&amp;</span><br><span class="line">                            (pattern.charAt(<span class="number">0</span>) == text.charAt(<span class="number">0</span>) || pattern.charAt(<span class="number">0</span>) == <span class="string">'.'</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pattern.length() &gt;= <span class="number">2</span> &amp;&amp; pattern.charAt(<span class="number">1</span>) == <span class="string">'*'</span>)&#123;</span><br><span class="line">            <span class="comment">//第一个回溯是应对不匹配的情况，</span></span><br><span class="line">            <span class="comment">//这个算法实际上只有两种情况，一种是s向后移动一位，另一种是p向后移动两位</span></span><br><span class="line">            <span class="comment">//每种情况可能会重复很多次，在每次都有可能会出现这两种情况</span></span><br><span class="line">            <span class="comment">//回溯算法就是将所有的情况都遍历一遍，查看是否有满足条件的情况</span></span><br><span class="line">            <span class="keyword">return</span> (isMatch(text, pattern.substring(<span class="number">2</span>)) ||</span><br><span class="line">            <span class="comment">//如果下一个字符是 * ，相当于是s向后移动一位，不过p保持不变，确实应该是这样，因为是*，这个和我那个匹配*的方法是一样的，如果出现</span></span><br><span class="line">                    (first_match &amp;&amp; isMatch(text.substring(<span class="number">1</span>), pattern)));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果不是 * ，还是传入后面的字符，不过p也向后移动一位</span></span><br><span class="line">            <span class="keyword">return</span> first_match &amp;&amp; isMatch(text.substring(<span class="number">1</span>), pattern.substring(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>动态规划就是将中间过程保存下来，避免重复计算</p>
</li>
<li><p>git协同工作的一般步骤</p>
<ol>
<li><p>选择一个文件夹作为仓库并初始化</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Git init</span><br></pre></td></tr></table></figure>
</li>
<li><p>与远程仓库建立连接</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Git remote add origin <span class="string">"远程仓库地址"</span></span><br><span class="line"></span><br><span class="line">Git remote  <span class="comment">#查看是否已经建立连接</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>拉取远程仓库的文件到本地</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Git pull origin(仓库名)  master(分支名)</span><br></pre></td></tr></table></figure>
</li>
<li><p>之后进行文件的修改</p>
</li>
<li><p>修改好后首先添加到暂存区</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Git add 文件名或者.  <span class="comment"># .表示全部文件</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>再将暂存区的文件提交到本地仓库</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Git commit -m <span class="string">"提交的名称"</span></span><br><span class="line"><span class="comment"># 如果不用-m选项，那么会打开编辑器，写提交信息</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>将本地的仓库的文件推送到远程仓库</p>
<p>首先因为开源项目很多人协同，有可能你和别人同时修改了一份文件，这样的话提交时会产生文件冲突所以在push之前    在做一步pull操作</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Git pull origin(仓库名)  master(分支名)</span><br></pre></td></tr></table></figure>

<p>接着进行push操作</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Git push origin(仓库名) master(分支名)</span><br></pre></td></tr></table></figure>
</li>
<li><p>登录github查看项目文件已经更新</p>
</li>
</ol>
</li>
</ol>
<hr>
<h1 id="04-11"><a href="#04-11" class="headerlink" title="04/11:"></a>04/11:</h1><h3 id="昨天结束了超算，感觉就像早就结束了"><a href="#昨天结束了超算，感觉就像早就结束了" class="headerlink" title="昨天结束了超算，感觉就像早就结束了"></a>昨天结束了超算，感觉就像早就结束了</h3><h3 id="关键字：微信小程序边距控制"><a href="#关键字：微信小程序边距控制" class="headerlink" title="关键字：微信小程序边距控制"></a>关键字：微信小程序边距控制</h3><ol>
<li><p>微信小程序边距控制</p>
<p>margin: 20rpx 10rpx 25rpx 10rpx ：如果提供全部四个参数值，将按上、右、下、左的顺序作用于四边。<br>margin：20rpx：如果只提供一个，将用于全部的四边。<br>margin：20rpx 20rpx：如果提供两个，第一个用于上、下，第二个用于左、右。<br>margin：20rpx 20rpx 10rpx：如果提供三个，第一个用于上，第二个用于左、右，第三个用于下。</p>
</li>
</ol>
<hr>
<h1 id="04-02"><a href="#04-02" class="headerlink" title="04/02:"></a>04/02:</h1><h3 id="第85天：无"><a href="#第85天：无" class="headerlink" title="第85天：无"></a>第85天：无</h3><h3 id="关键字："><a href="#关键字：" class="headerlink" title="关键字："></a>关键字：</h3><ol>
<li><p>列表：</p>
<li>是列表中的标签，表示列表中的每一项，，<ol>是有序列表，<ul>是无序列表
</li>
<li><p>派生选择器，</p>
<p>就是可以通过上下文关系来定义样式，如</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span>li strong &#123;</span><br><span class="line">    font-style: italic;</span><br><span class="line">    font-weight: normal;</span><br><span class="line">  &#125;<span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">strong</span>&gt;</span>我是粗体字，不是斜体字，因为我不在列表当中，所以这个规则对我不起作用<span class="tag">&lt;/<span class="name">strong</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">strong</span>&gt;</span>我是斜体字。这是因为 strong 元素位于 li 元素内。<span class="tag">&lt;/<span class="name">strong</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>我是正常的字体。<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>JavaScript “显示”数据：</p>
<ol>
<li>使用 window.alert() 写入警告框</li>
<li>使用 document.write() 写入 HTML 输出</li>
<li>使用 innerHTML 写入 HTML 元素</li>
<li>使用 console.log() 写入浏览器控制台</li>
</ol>
<p>在 HTML 文档完全加载后使用 document.write() 将删除所有已有的 HTML </p>
</li>
<li><p>let：</p>
<p>变量的块作用域</p>
<p>JS里面没有块级作用域<br>for (var i = 0; i &lt; 10; i++) {<br>  // 代码块<br>}<br>return i;<br>这段代码最后将返回10，这里就体现了let的作用</p>
</li>
<li><p>比较：</p>
<p>== 比较运算符总是在比较之前进行类型转换（以匹配类型）。<br>=== 运算符会强制对值和类型进行比较</p>
</li>
<li><p>运算：</p>
<p>var x = 10 + “5”;         // x 中的结果是　“105”</p>
</li>
<li><p>对象在定义之后，可以继续添加新的内容，如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> person = &#123;</span></span><br><span class="line"><span class="actionscript">  firstName: <span class="string">"Bill"</span>,</span></span><br><span class="line"><span class="actionscript">  lastName : <span class="string">"Gates"</span>,</span></span><br><span class="line">  id     : 678,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="actionscript">person.name = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">  <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">" "</span> + <span class="keyword">this</span>.lastName;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="actionscript"><span class="comment">//向对象person中添加了新的方法person.name()</span></span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.getElementById(<span class="string">"demo"</span>).innerHTML =</span></span><br><span class="line"><span class="actionscript"><span class="string">"My friend is "</span> + person.name(); <span class="comment">//如果使用name而不是name()进行访问，则获取函数定义</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 prototype 属性<br>JavaScript prototype 属性允许您为对象构造器添加新属性，如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">first, last, age, eyecolor</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.firstName = first;</span><br><span class="line">    <span class="keyword">this</span>.lastName = last;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.eyeColor = eyecolor;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.nationality = <span class="string">"English"</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>自调用函数：<br>(function () {</p>
<pre><code>var x = &quot;Hello!!&quot;;      //我会调用我自己</code></pre><p>})();</p>
<p>==自调用函数是一次性函数，里面的内容只执行一次==</p>
</li>
<li><p>arguments</p>
<p>arguments.length：获取参数的总数量<br>arguments[i] 获取第i个参数，这样就可以逐个处理参数了</p>
</li>
<li><p>call() 和 apply()</p>
<ol>
<li>都可以将其他对象传到方法里面</li>
<li>不同之处是：<ol>
<li>call() 方法分别接受参数。</li>
<li>apply() 方法接受数组形式的参数。</li>
<li>如果要使用数组而不是参数列表，则 apply() 方法非常方便。</li>
</ol>
</li>
</ol>
</li>
<li><p>函数访问函数外定义的变量</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">4</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>JS闭包：</p>
<p><img src="https://raw.githubusercontent.com/Pipepw/FigureBed/master/blog_files/img/PicGo-Github-PicBed/image-20200403095111668.png" alt="image-20200403095111668"></p>
</li>
</ol>
<hr>
<h1 id="04-01"><a href="#04-01" class="headerlink" title="04/01:"></a>04/01:</h1><h3 id="第84天：无"><a href="#第84天：无" class="headerlink" title="第84天：无"></a>第84天：无</h3><h3 id="关键字：使用redis的方法、查询redis服务器中的数据、改进redis、在js中获取id、安装android-sdk、做项目的步骤、SQL的好工具、空元素标签、换行、属性、样式、创建链接、内敛元素、在块中使用相同的样式、同一浏览器中显示多个页面、使用JS"><a href="#关键字：使用redis的方法、查询redis服务器中的数据、改进redis、在js中获取id、安装android-sdk、做项目的步骤、SQL的好工具、空元素标签、换行、属性、样式、创建链接、内敛元素、在块中使用相同的样式、同一浏览器中显示多个页面、使用JS" class="headerlink" title="关键字：使用redis的方法、查询redis服务器中的数据、改进redis、在js中获取id、安装android sdk、做项目的步骤、SQL的好工具、空元素标签、换行、属性、样式、创建链接、内敛元素、在块中使用相同的样式、同一浏览器中显示多个页面、使用JS"></a>关键字：使用redis的方法、查询redis服务器中的数据、改进redis、在js中获取id、安装android sdk、做项目的步骤、SQL的好工具、空元素标签、换行、属性、样式、创建链接、内敛元素、在块中使用相同的样式、同一浏览器中显示多个页面、使用JS</h3><ol>
<li><p>使用redis的方法：</p>
<p><img src="https://raw.githubusercontent.com/Pipepw/FigureBed/master/blog_files/img/PicGo-Github-PicBed/image-20200401115558796.png" alt="image-20200401115558796"></p>
</li>
<li><p>查询redis服务器中的数据：</p>
<p><img src="https://raw.githubusercontent.com/Pipepw/FigureBed/master/blog_files/img/PicGo-Github-PicBed/image-20200401115656369.png" alt="image-20200401115656369"></p>
</li>
<li><p>改进redis：</p>
<p>将分数也查询出来</p>
<p><img src="https://raw.githubusercontent.com/Pipepw/FigureBed/master/blog_files/img/PicGo-Github-PicBed/image-20200401120204988.png" alt="image-20200401120204988"></p>
</li>
<li><p>在js中获取id：</p>
<p><img src="https://raw.githubusercontent.com/Pipepw/FigureBed/master/blog_files/img/PicGo-Github-PicBed/image-20200401151607471.png" alt="image-20200401151607471"></p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/37974829" target="_blank" rel="noopener">安装android sdk</a></p>
</li>
<li><p>做项目的步骤：</p>
<ol>
<li>效果：先把表面做出来，也就是先把前端做出来，中间用假的数据</li>
<li>分析：分析功能，需要的函数</li>
<li>代码实现（分为前台代码和后台代码）<ol>
<li>后台代码：Servlet、Service和Dao</li>
<li>前台代码：这里的前台代码就是将初始的假数据通过请求的方式转化为真实数据</li>
</ol>
</li>
</ol>
<p>前端通过id之类的标签对需要处理的对象进行定位，然后在进行相应的处理</p>
</li>
<li><p>SQL的好工具<br>SQLyog ULtimate64</p>
</li>
<li><p>空元素标签：</p>
<p>以开始标签结束而结束的标签是空元素标签如</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"w3school.jpg"</span> <span class="attr">width</span>=<span class="string">"104"</span> <span class="attr">height</span>=<span class="string">"142"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>换行：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>属性：</p>
<p>在标签内使用</p>
<p>属性可以是原本就有的，也可以是自己定义的，但是不知道自己定义的属性可以不可以在其他地方用到</p>
</li>
<li><p>样式：</p>
<ol>
<li>外部样式表<br>通过link进行链接</li>
</ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"mystyle.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>内部样式表<br>通过style进行定义</li>
</ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-tag">body</span> &#123;<span class="attribute">background-color</span>: red&#125;</span></span><br><span class="line"><span class="css"><span class="selector-tag">p</span> &#123;<span class="attribute">margin-left</span>: <span class="number">20px</span>&#125;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>内联样式<br>在标签内部</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"color: red; margin-left: 20px"</span>&gt;</span></span><br><span class="line">This is a paragraph</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>当样式需要被很多页面用到的时候，使用外表样式表就很方便</p>
</li>
<li><p>创建链接：</p>
<ol>
<li><p>通过使用 <a> 标签在 HTML 中创建链接。</p>
</li>
<li><p>有两种使用 <a> 标签的方式：</p>
<ol>
<li>通过使用 href 属性 - 创建指向另一个文档的链接</li>
<li>通过使用 name 属性 - 创建文档内的书签</li>
</ol>
</li>
<li><p>name的用法：</p>
<ol>
<li>首先，在 HTML 文档中对锚进行命名（创建一个书签）：</li>
</ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">name</span>=<span class="string">"tips"</span>&gt;</span>基本的注意事项 - 有用的提示<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>然后，在同一个文档中创建指向该锚的链接：</li>
</ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#tips"</span>&gt;</span>有用的提示<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>也可以在其他页面中创建指向该锚的链接：</li>
</ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.w3school.com.cn/html/html_links.asp#tips"</span>&gt;</span>有用的提示<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在上面的代码中，将 # 符号和锚名称添加到 URL 的末端，就可以直接链接到 tips 这个命名锚了。</p>
</li>
</ol>
</li>
<li><p>内敛元素：</p>
<p>内联元素在显示时通常不会以新行开始。<br>例子：<b>, <td>, <a>, <img></p>
</li>
<li><p>在块中使用相同的样式</p>
<p>在HTML中定义块，在块中使用属性如id、class，然后在CSS中根据属性名来进行相应的修饰（style内）</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-tag">table</span><span class="selector-class">.lamp</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">width</span><span class="selector-pseudo">:100</span>%;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">border</span><span class="selector-pseudo">:1px</span> <span class="selector-tag">solid</span> <span class="selector-id">#d4d4d4</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-tag">table</span><span class="selector-class">.lamp</span> <span class="selector-tag">th</span>, <span class="selector-tag">td</span> &#123; </span></span><br><span class="line"><span class="css">    <span class="selector-tag">padding</span><span class="selector-pseudo">:10px</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-tag">table</span><span class="selector-class">.lamp</span> <span class="selector-tag">th</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">width</span><span class="selector-pseudo">:40px</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">class</span>=<span class="string">"lamp"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"/images/lamp.jpg"</span> <span class="attr">alt</span>=<span class="string">"Note"</span> <span class="attr">style</span>=<span class="string">"height:32px;width:32px"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">    The table element was not designed to be a layout tool.</span><br><span class="line">  <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>同一浏览器中显示多个页面</p>
<ol>
<li><p>使用iframe在网页内显示网页<br>添加 iframe 的语法</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"URL"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>URL 指向隔离页面的位置。</p>
</li>
<li><p>Iframe - 设置高度和宽度</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"demo_iframe.htm"</span> <span class="attr">width</span>=<span class="string">"200"</span> <span class="attr">height</span>=<span class="string">"200"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>使用JS</p>
<p>在<script>标签中定义JS脚本，可以使用src属性指向外部脚本文件</p>
</li>
</ol>
<hr>
<h1 id="03-30："><a href="#03-30：" class="headerlink" title="03/30："></a>03/30：</h1><h3 id="第82天：无"><a href="#第82天：无" class="headerlink" title="第82天：无"></a>第82天：无</h3><h3 id="关键字：debug方法、三层设计、cookie和session、MVC模式、写代码习惯、RTTI-Run-Time-Type-Identification-、Class类、亮点1-将结构修改为MVC、改成MVC的过程、后端接受访问、idea输出乱码"><a href="#关键字：debug方法、三层设计、cookie和session、MVC模式、写代码习惯、RTTI-Run-Time-Type-Identification-、Class类、亮点1-将结构修改为MVC、改成MVC的过程、后端接受访问、idea输出乱码" class="headerlink" title="关键字：debug方法、三层设计、cookie和session、MVC模式、写代码习惯、RTTI(Run-Time Type Identification)、Class类、亮点1.将结构修改为MVC、改成MVC的过程、后端接受访问、idea输出乱码"></a>关键字：debug方法、三层设计、cookie和session、MVC模式、写代码习惯、RTTI(Run-Time Type Identification)、Class类、亮点1.将结构修改为MVC、改成MVC的过程、后端接受访问、idea输出乱码</h3><ol>
<li><p>debug方法：</p>
<p>报错之后，看最后一个错误信息，然后在里面找自己写的代码，从中查找错误</p>
</li>
<li><p>三层设计：</p>
<ol>
<li>Dao就是与数据库进行对接的地方</li>
<li>Servlet是主要的工作点，大部分程序的逻辑设计都在这里</li>
<li>Service则是实现Servlet中需要的方法，过程中配合Dao访问数据库</li>
</ol>
</li>
<li><p>cookie和session：</p>
<ol>
<li>cookie是在客户端保持状态，就像是奶茶店的积分卡</li>
<li>session则是在服务器端保持状态，就像会员卡</li>
</ol>
</li>
<li><p>MVC模式：</p>
<ol>
<li>Model（模型）：模型就是存放数据的对象或者JAVA POJO</li>
<li>View（视图）：模型的数据的可视化</li>
<li>Controller（控制器）：控制Model中的数据，并更新View</li>
</ol>
</li>
<li><p>写代码习惯：</p>
<p>在输出后面加上自己预期的结果注释</p>
</li>
<li><p>RTTI(Run-Time Type Identification)：</p>
<p>作用是在运行时识别一个对象的类型和类的信息，RRTI有两种，一种是在编译期知道所有类型，另一种是反射机制，它允许在运行时发现和使用类型的信息</p>
</li>
<li><p>Class类：</p>
<ol>
<li>在Java中用来表示运行时类型信息的对应类</li>
<li>每个类都有对应的Class对象，由JVM进行创建保存在同名的.class文件中</li>
<li>Class对象的作用：在new一个新的对象或者引用静态成员变量时，JVM中的类加载器子系统会将对应的Class对象加载到JVM中，然后JVM根据这个Class对象中的信息创建需要的对象或者静态变量引用。所以其作用就是在运行时提供或获得某个对象的类型信息</li>
</ol>
</li>
<li><p>亮点1.将结构修改为MVC：<br><img src="https://raw.githubusercontent.com/Pipepw/FigureBed/master/blog_files/img/PicGo-Github-PicBed/image-20200330235849036.png" alt="image-20200330235849036"></p>
</li>
<li><p>改成MVC的过程：</p>
<p>他这么做，是为了简化Servlet，之前是一个操作就有一个Servlet，优化之后是数据库中的一个表对应一个Servlet，为什么说是MVC呢？其中Module就是一个Dao，view就是前端的界面，Controller就是优化之后的Servlet。为什么之前不是MVC呢？之前是一个操作对应一个Servlet，那么显然是没有Controller的，每一个Servlet操纵的数据也不统一，自然也就没有module了。<br>为什么之前要一个操作对应一个Servlet呢，因为Servlet继承HttpServlet，而在HttpServlet中有个service方法，这个service方法则可以根据不同的请求来执行不同的操作，从而实现对方法的分发，这个方法的分发就是在service里面执行调用这个所需的方法，也就是说，比如初始版本就是调用doGet或者doPost方法，但是你又不能修改HttpServlet中的内容，所以最后还是需要执行doGet或者doPost方法，然后在doGet或者doPost方法中执行所需的方法，这样就完成了一次抽象吧，</p>
</li>
<li><p>后端接受访问：</p>
<p>通过@WebServlet("/user/*")来指定访问的地址，如果访问这个地址，那么就会执行这个方法<br><img src="https://raw.githubusercontent.com/Pipepw/FigureBed/master/blog_files/img/PicGo-Github-PicBed/image-20200330235925998.png" alt="image-20200330235925998"></p>
</li>
<li><p>idea输出乱码：</p>
<p><img src="https://raw.githubusercontent.com/Pipepw/FigureBed/master/blog_files/img/PicGo-Github-PicBed/image-20200331000938202.png" alt="image-20200331000938202"></p>
</li>
</ol>
<hr>
<h1 id="03-28"><a href="#03-28" class="headerlink" title="03/28:"></a>03/28:</h1><h3 id="第80天：无"><a href="#第80天：无" class="headerlink" title="第80天：无"></a>第80天：无</h3><h3 id="关键字：Java-DAO模式、项目的结构、经验、注解、Java-Bean、注解的作用、Java依赖注入与控制反转、框架的3个最基本特征、Java事务、融合门、查看mysql的信息、错误、Java-POJO、导入项目、小程序前后端通信、小程序的success回调函数、对Java后端的理解"><a href="#关键字：Java-DAO模式、项目的结构、经验、注解、Java-Bean、注解的作用、Java依赖注入与控制反转、框架的3个最基本特征、Java事务、融合门、查看mysql的信息、错误、Java-POJO、导入项目、小程序前后端通信、小程序的success回调函数、对Java后端的理解" class="headerlink" title="关键字：Java DAO模式、项目的结构、经验、注解、Java Bean、注解的作用、Java依赖注入与控制反转、框架的3个最基本特征、Java事务、融合门、查看mysql的信息、错误、Java POJO、导入项目、小程序前后端通信、小程序的success回调函数、对Java后端的理解"></a>关键字：Java DAO模式、项目的结构、经验、注解、Java Bean、注解的作用、Java依赖注入与控制反转、框架的3个最基本特征、Java事务、融合门、查看mysql的信息、错误、Java POJO、导入项目、小程序前后端通信、小程序的success回调函数、对Java后端的理解</h3><ol>
<li><p>Java DAO模式：就是将数据库的操作都封装起来<br>组成部分：</p>
<ol>
<li>DAO接口：将数据库的操作定义为抽象方法</li>
<li>DAO实现类：针对不同数据库各处DAO接口定义方法的具体实现</li>
<li>实体类：用于存放与传输对象数据</li>
<li>数据库连接和关闭工具：避免数据库连接</li>
</ol>
</li>
<li><p>项目的结构</p>
<ol>
<li>一个项目分为持久层、业务层以及展现层</li>
<li>持久层负责数据的访问和操作，也就是从数据库表中加载数据并实例化领域对象，领域对象就是实体类，领域对象的包为com.smart.domain</li>
<li>领域对象一般要实现Serializable接口，以便可以序列化</li>
</ol>
</li>
<li><p>经验：</p>
<ol>
<li>一般在每行SQL语句的句前和句尾都加一个空格，避免语句组合后的错误</li>
<li>在空白处右键菜单Run 'UserServiceTest'，则是运行所有的测试方法，如果鼠标在一个测试方法块内，则会只运行这一个测试方法</li>
</ol>
</li>
<li><p>注解：</p>
<ol>
<li>@Service注解：将类标注为一个服务层的Bean</li>
<li>@Autowired：自动装配，作用是为了消除代码Java代码里面的getter/setter与bean属性中的property</li>
<li>@Transactional：声明事务</li>
<li>@ContextConfiguration：用来指定Spring的配置文件</li>
</ol>
</li>
<li><p>Java Bean</p>
<p>Java Bean就是一种约定成俗的规定，为了保持向后兼容性<br>规定如下：</p>
<ol>
<li>所有属性为private</li>
<li>提供默认构造方法</li>
<li>提供getter和setter</li>
<li>实现serializable接口</li>
</ol>
</li>
<li><p>注解的作用：</p>
<p>传统Spring的做法是使用.xml文件来对bean进行注入或者配置aop、事物，缺点是：一方面xml很大，另一方面是写代码的过程中需要不断在.java文件和.xml文件之间进行切换，繁琐且降低效率<br>使用注解就可以在.java文件中进行配置了<br>所以注解的作用就是减少对.xml文件（spring配置文件）的修改和编写，当然对.java文件也有效果</p>
</li>
<li><p>Java依赖注入与控制反转</p>
<ol>
<li><p>Java 依赖注入：把一个对象实例传给另一个新建对象</p>
</li>
<li><p>Java 控制反转：从主动变被动</p>
<p>传统的程序开发，是从main函数开始，调用各种各样库来完成一个程序，这是开发者控制着整个运行过程<br>使用框架开发，是框架控制整个运行过程</p>
</li>
</ol>
</li>
<li><p>框架的3个最基本特征：</p>
<ol>
<li>main函数，即程序入口</li>
<li>创建对象</li>
<li>装配对象（注入）</li>
</ol>
</li>
<li><p>Java事务</p>
<p>事物是逻辑上的一组操作，要么都执行，要么都不执行（就是对一系列的操作进行限制）。是对数据库的操作而言的</p>
<p>事务的特性（ACID）</p>
<ol>
<li>原子性：事务是最小的执行单位，事务的原子性确保动作要么都完成，要么完全不起作用</li>
<li>一致性：执行事务前后，数据保持一致（哪里的数据呢）</li>
<li>隔离性：并发访问数据库时，一个用户的数据库不被其他事务所干扰，各并发事务之间数据库时独立的</li>
<li>持久性：一个事务提交之后，它对数据库中数据的改变时持久的，即使数据库发生故障页不应该对其有任何影响<br>Spring事务管理分为编码是和声明式两那种。<ol>
<li>编码式就是对程序进行修改以管理事务。</li>
<li>声明式基于AOP，将具体业务逻辑与事务处理解耦，使业务逻辑代码不受污染，所以使用声明式较多（只知道，不理解）<br>声明式事务有两种：一种是在配置文件（xml）中做相关的事务规则声明，另一种就是使用@Transactional注解了</li>
</ol>
</li>
</ol>
</li>
<li><p>融合门：</p>
<p>同一个位置进行多次使用，将28个循环改成一个循环，在一个循环里面进行判断</p>
</li>
<li><p>查看mysql的信息：</p>
<ol>
<li>使用 show databases;查看数据库的信息，有哪些数据库</li>
<li>使用 use databaseName;选择使用的数据库</li>
<li>show tables; 查看该数据的的表项</li>
<li>也可以使用 show tables from databaseName;查看信息</li>
<li>desc 表名，查看数据库表信息</li>
<li>修改字段的名字：alter table 表名 change 旧字段名 新字段名 新数据类型</li>
</ol>
</li>
<li><p>错误：</p>
<ol>
<li><p>当出现Unknown column 'user_id' in 'field list'这类错误时，查看数据表项中的字段与程序中使用的字段是否一样，如果不一样，则进行相应的修改</p>
</li>
<li><p>出现 “not find catalina.jar”：原因：移动tomcat文件夹</p>
</li>
<li><p>tomcat使用startup.bat启动出现乱码时，修改tomcat/conf下的loggin.properties</p>
<p><img src="https://raw.githubusercontent.com/Pipepw/FigureBed/master/blog_files/img/PicGo-Github-PicBed/image-20200329100135825.png" alt="image-20200329100135825"></p>
</li>
<li><p>不能启动tomcat的原因可能是因为将tomcat放到了比较重要的地方，导致需要管理员权限</p>
</li>
</ol>
</li>
<li><p>Java POJO：</p>
<p>简单java对象，就是没有继承任何类，也没有实现任何接口，没有被其他框架侵入的Java对象</p>
</li>
<li><p>导入项目：</p>
<p>不同IDE的项目有着不同的环境，不同的IDE也有方法进行区分，比如eclipse里面有eclipse图标的文件，idea的项目里面有.idea文件夹，不同IDE的项目不能直接在另一个IDE中添加，要找到方法，比如<a href="https://blog.csdn.net/qq_33442160/article/details/81395079" target="_blank" rel="noopener">IDEAE导入eclipse项目</a></p>
</li>
<li><p>小程序前后端通信：</p>
<p>小程序与Java后台通信的方法：将数据通过get方式传到Java servlet类，servlet得到微信小程序的数据打印出来并返回一个数据给微信小程序，从而实现一个最简单的前后端通信</p>
</li>
<li><p>小程序的success回调函数：</p>
<p>微信小程序的success回调函数是个很广义的函数，不仅在与服务器通信之后使用，在获取本地图片之后也可以使用，反正就是成功完成一个操作之后就可以使用，不过传递给它的参数是由调用的函数决定的，根据不同的接口来定</p>
</li>
<li><p>对Java后端的理解：</p>
<ol>
<li>服务器有一个IP地址，这个IP地址就相当于是在/home/user目录下面了，所以后面可以跟地址，比如10.243.119.29:8080//test2_Web_exploded/upload就是访问的那个目录</li>
<li>Java通过接口获取数据之后进行相应的处理，然后再把数据返回</li>
<li>反正就是到处使用接口</li>
</ol>
</li>
</ol>
<hr>
<h1 id="03-26："><a href="#03-26：" class="headerlink" title="03/26："></a>03/26：</h1><h3 id="第78天：无"><a href="#第78天：无" class="headerlink" title="第78天：无"></a>第78天：无</h3><h3 id="关键字：微信小程序的执行与构成、小程序全局变量、数据绑定、API一般调用的约定、arget与currentTarget的区别、arget与currentTarget的区别、将数据从wxml传到js、JavaScript：require、exports、module-exports、注解"><a href="#关键字：微信小程序的执行与构成、小程序全局变量、数据绑定、API一般调用的约定、arget与currentTarget的区别、arget与currentTarget的区别、将数据从wxml传到js、JavaScript：require、exports、module-exports、注解" class="headerlink" title="关键字：微信小程序的执行与构成、小程序全局变量、数据绑定、API一般调用的约定、arget与currentTarget的区别、arget与currentTarget的区别、将数据从wxml传到js、JavaScript：require、exports、module.exports、注解"></a>关键字：微信小程序的执行与构成、小程序全局变量、数据绑定、API一般调用的约定、arget与currentTarget的区别、arget与currentTarget的区别、将数据从wxml传到js、JavaScript：require、exports、module.exports、注解</h3><ol>
<li><p>微信小程序的执行与构成：</p>
<ol>
<li>小程序执行的入口文件是 app.js ，当app.js 执行结束之后，小程序会按照在 app.json中定义的pages顺序执行<br>每个项目总有一个入口文件，通过入口文件就可以知道程序的功能以及架构，在QuEST中也是这样</li>
<li>渲染层与数据相关，逻辑层负责产生和处理数据，逻辑层通过Page实力的setData方法传递数据到渲染层<br>渲染层、逻辑层以及第三方服务器之间需要通过微信客户端来进行中转</li>
<li>一个页面由三部分组成：界面、配置和逻辑，界面由WXML和WXSS文件描述，配置由JSON文件描述，逻辑由JS脚本文件负责。一个页面的文件需要防止在同一个目录下（一一对应关系），WXML和JS文件必须存在。</li>
<li>页面路径在app.json的pages中声明</li>
<li>在js文件中的Page就是页面构造器</li>
<li>通过wx.navigatoTo进入一个新的页面，页面保存在页面栈中</li>
<li>在wxml中通过bindtap定义点击事件，具体的处理逻辑中在js中定义，bindtap="tapName"这样就形成了一一对应关系</li>
</ol>
</li>
<li><p>小程序全局变量</p>
<p>当需要全局变量时，通过使用getApp()获取全局的实例，然后在设置相关的属性值，对应的属性值就相当于是全局变量了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/ a.js</span><br><span class="line"><span class="comment">// 获取全局变量</span></span><br><span class="line"><span class="keyword">var</span> global = getApp()</span><br><span class="line"></span><br><span class="line">global.globalValue = <span class="string">'globalValue'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="comment">// 访问全局变量</span></span><br><span class="line"><span class="keyword">var</span> global = getApp()</span><br><span class="line"><span class="built_in">console</span>.log(global.globalValue) <span class="comment">// 输出 globalValue</span></span><br><span class="line"><span class="comment">// 如果需要全局的数据可以在任何文件中都可以安全的被访问到，那么就在App()中进行设置</span></span><br><span class="line">App(&#123;</span><br><span class="line">	globalData:<span class="number">1</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>数据绑定：</p>
<p>其实讲的是渲染层和逻辑层是通过Dom树来进行转换的，但是具体的使用还是在逻辑层用setData()方法来修改变量的值</p>
</li>
<li><p>API一般调用的约定：</p>
<pre><code>wx.on* 开头的 API 是监听某个事件发生的API接口，接受一个 Callback 函数作为参数。当该事件触发时，会调用 Callback 函数。
如未特殊约定，多数 API 接口为异步接口 ，都接受一个Object作为参数。
API的Object参数一般由success、fail、complete三个回调来接收接口调用结果，示例代码如代码清单3-17所示，详细说明如表3-9所示。
wx.get* 开头的API是获取宿主环境数据的接口。
wx.set* 开头的API是写入数据到宿主环境的接口。</code></pre></li>
<li><p>arget与currentTarget的区别：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">&lt;!-- page.wxml --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">view</span> <span class="attr">id</span>=<span class="string">"outer"</span> <span class="attr">catchtap</span>=<span class="string">"handleTap"</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">view</span> <span class="attr">id</span>=<span class="string">"inner"</span>&gt;</span>点击我<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure>


</li>
</ol>
<p>   target是触发该事件的源头组件，currentTarget是当前事件所绑定的组件，在这个例子中，target是内层view，currentTarget是外层view</p>
<ol start="6">
<li><p>将数据从wxml传到js：</p>
<p>首先通过一个参数将对象传递过来，然后有各种数据都在这个对象里面</p>
</li>
<li><p>JavaScript：require、exports、module.exports</p>
<p>require用来加载代码，exports和module.exports用来到导出代码</p>
<ol>
<li>module.exports初始化值为一个空对象{}</li>
<li>exports是指向module.exports的引用</li>
<li>require()返回的是module.exports，而不是exports<br>在js中，{}就表示一个对象</li>
</ol>
</li>
<li><p>注解：</p>
<p>如果需要覆盖掉父类的方法，则需要使用@Override注解</p>
<p>注解的作用：</p>
<ol>
<li>编译检查</li>
<li>在反射中使用</li>
<li>根据注解生成帮助文档</li>
<li>帮助查看代码</li>
</ol>
</li>
</ol>
<hr>
<h1 id="03-25："><a href="#03-25：" class="headerlink" title="03/25："></a>03/25：</h1><h3 id="第77天：现在已经开始有些懈怠了，感觉优化也没有方法了，在做自己的事情"><a href="#第77天：现在已经开始有些懈怠了，感觉优化也没有方法了，在做自己的事情" class="headerlink" title="第77天：现在已经开始有些懈怠了，感觉优化也没有方法了，在做自己的事情"></a>第77天：现在已经开始有些懈怠了，感觉优化也没有方法了，在做自己的事情</h3><h3 id="关键字：马拉车优化、在nvvp中查看行信息、使用nvvp分析、其他、cmd查看目录、windows环境变量、git-bash进入有空格的文件夹、使用hexo遇到的一些问题、java的String、刷题注意、StringBuilder和StringBuffer、微信小程序、看代码的方法"><a href="#关键字：马拉车优化、在nvvp中查看行信息、使用nvvp分析、其他、cmd查看目录、windows环境变量、git-bash进入有空格的文件夹、使用hexo遇到的一些问题、java的String、刷题注意、StringBuilder和StringBuffer、微信小程序、看代码的方法" class="headerlink" title="关键字：马拉车优化、在nvvp中查看行信息、使用nvvp分析、其他、cmd查看目录、windows环境变量、git bash进入有空格的文件夹、使用hexo遇到的一些问题、java的String、刷题注意、StringBuilder和StringBuffer、微信小程序、看代码的方法"></a>关键字：马拉车优化、在nvvp中查看行信息、使用nvvp分析、其他、cmd查看目录、windows环境变量、git bash进入有空格的文件夹、使用hexo遇到的一些问题、java的String、刷题注意、StringBuilder和StringBuffer、微信小程序、看代码的方法</h3><ol>
<li><p>马拉车优化：</p>
<ol>
<li>方法：将mx设置为所有回文子串的最后边界，而不是最长回文子串的最右边界，这样就能够减少更多的比较了</li>
<li>需要注意的地方：比较的时候需要重新考虑一下</li>
<li>结果：负优化（挺离谱的）</li>
</ol>
</li>
<li><p>在nvvp中查看行信息：nvvc -lineinfo</p>
</li>
<li><p>使用nvvp分析：</p>
<ol>
<li>分析也是分层次的，在高层次中有可能会获取不到有用的信息，比如那个饼状图，应该结合代码来分析</li>
<li>更底层的分析就是查看 Kernel Profile -PC Sampling，PC就是程序计数器，点击里面的源码文件，就可以看到关键的源码以及对应的</li>
<li>内存利用、计算利用以及与理论峰值的关系:</li>
</ol>
<p><img src="https://raw.githubusercontent.com/Pipepw/FigureBed/master/blog_files/img/PicGo-Github-PicBed/image-20200517083546073.png" alt="image-20200517083546073"> </p>
</li>
<li><p>其他：分享主题在上，个人简历在下，因为内容是主要的，重点是内容是主要的，其他地方也需要注意这个</p>
</li>
<li><p>cmd查看目录：cmd使用dir查看目录</p>
</li>
<li><p>windows环境变量：</p>
<ol>
<li>当windows环境变量配置失败时，进入文件目录下测试是否可以使用，如果能够使用，那么将当前目录配置为环境变量，再次尝试是否可以使用，如果还是不能使用，那么重启之后应该就可以使用</li>
<li>有时候在win+r能生效，而用listary或者其他软件打开的cmd却不能生效</li>
</ol>
</li>
<li><p>git bash进入有空格的文件夹：（用双引号将空格括起来）</p>
<p>例如 进入文件名为JS Study的文件夹</p>
<p>cd JS" "Study</p>
</li>
<li><p>使用hexo遇到的一些问题：</p>
<ol>
<li><p>上传总是需要密码：</p>
<p>hexo 的配置文件 _config.yml 中的 deploy 属性。</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@github.com:chengjianhua/chengjianhua.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>

<p>将其中的 repo修改成了<a href="mailto:git@github.com">git@github.com</a>:chengjianhua/chengjianhua.github.io.git</p>
</li>
<li><p>本地预览与网页中的不同：</p>
<ol>
<li><p>可能原因：本地缓存的影响</p>
</li>
<li><p>解决方法：</p>
<p>在上传之前先使用 hexo clean 清楚缓存</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>java的String：</p>
<ol>
<li>java 的string不能像数组一样动态赋值，所以先声明一个字符数组，赋值结束之后将其转换为String</li>
<li>字符数组转String的方法：<ol>
<li>直接在声明string的时候将其作为i值传递进去</li>
<li>使用String.valueOf(temp);进行转换，其中temp是char[] temp = new char[10];</li>
</ol>
</li>
</ol>
</li>
<li><p>刷题注意：进行除法运算的时候，要注意被除数不能为0</p>
</li>
<li><p>StringBuilder和StringBuffer：</p>
<ol>
<li><p>String类不能被修改，并且回产生新的未使用对象，而StringBuffer和StringBuilder能够被多次修改并且不产生新的未使用的对象</p>
</li>
<li><p>两者的差别：StringBuilder的方法不是线程安全的（不能同步访问），所以相较于StringBuffer有速度优势（不需要进行判断）</p>
</li>
<li><p>使用方法：两者是一样的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">    StringBuffer sBuffer = <span class="keyword">new</span> StringBuffer(<span class="string">"菜鸟教程官网："</span>);</span><br><span class="line">    sBuffer.append(<span class="string">"www"</span>);</span><br><span class="line">    sBuffer.append(<span class="string">".runoob"</span>);</span><br><span class="line">    sBuffer.append(<span class="string">".com"</span>);</span><br><span class="line">    System.out.println(sBuffer);  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>常用函数：</p>
<blockquote>
<p>.append(String s)：将字符串追加到后面<br>.reverse()：反转<br>.delete(int start,int end)：删除这段字符串<br>.insert(int offset,int i)：将int 参数的字符串表现形式插入此序列中（这个不太明白）<br>.replace(int start,int end,String str)：替换</p>
</blockquote>
</li>
</ol>
</li>
<li><p>微信小程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">1. 通过使用&#123;&#123;&#125;&#125;来进行数据绑定</span><br><span class="line"></span><br><span class="line">2. 将index和wxml的顺序换一下就能显示了</span><br><span class="line"></span><br><span class="line">3. 在标签的尖括号中的是属性值</span><br><span class="line"></span><br><span class="line">4. &#123;&#123;&#125;&#125;中还可以进行简单的运算，所以&#123;&#123;&#125;&#125;就相当于是一个变量了</span><br><span class="line"></span><br><span class="line">5. 使用\&lt;block&#x2F;&gt;将多个组件包装起来</span><br><span class="line"></span><br><span class="line">6. 使用wx:for&#x3D;&quot;&#123;&#123;array&#125;&#125;&quot;绑定一个数组，就相当于是对数组进行便利了，在wx.。。。中都是&quot;&#123;&#123;&#125;&#125;&quot;</span><br><span class="line"></span><br><span class="line">7. 在wxml中并不进行赋值操作，&#123;&#123;&#125;&#125;都只是变量，相当于就是一个输出，&#123;&#123;&#125;&#125;相当于是%d之类的</span><br><span class="line"></span><br><span class="line">8. wx:key&#x3D;“xxx&quot;，需要xxx是数组中有唯一性的变量</span><br><span class="line"></span><br><span class="line">   如果使用wx:key&#x3D;&quot;*this&quot;，则需要数组的item是唯一的字符串或者数字</span><br><span class="line"></span><br><span class="line">9. wxss文件名与页面名是同名的，这样就形成了一一对应关系，从而确定要渲染的页面</span><br><span class="line"></span><br><span class="line">10. 微信开发者工具是用来写前端的</span><br><span class="line"></span><br><span class="line">11. 小程序的代码运行在腾讯的服务器上，自己编写的java运行在自己部署的服务器上，通过API进行通信就可以了</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="13">
<li><p>看代码的方法：</p>
<ol>
<li>搞清楚每一个部分的作用是什么</li>
<li>看每个部分的细节</li>
</ol>
</li>
</ol>
<p>​      </p>
<hr>
<h1 id="03-17："><a href="#03-17：" class="headerlink" title="03/17："></a>03/17：</h1><h3 id="第70天：今天主要是看GPU分析程序的工具，以及优化程序的方法和步骤"><a href="#第70天：今天主要是看GPU分析程序的工具，以及优化程序的方法和步骤" class="headerlink" title="第70天：今天主要是看GPU分析程序的工具，以及优化程序的方法和步骤"></a>第70天：今天主要是看GPU分析程序的工具，以及优化程序的方法和步骤</h3><h3 id="关键字：安装配置idea、nvprof、优化程序的方法、改进"><a href="#关键字：安装配置idea、nvprof、优化程序的方法、改进" class="headerlink" title="关键字：安装配置idea、nvprof、优化程序的方法、改进"></a>关键字：安装配置idea、nvprof、优化程序的方法、改进</h3><ol>
<li><p>安装配置idea：</p>
<ol>
<li>安装IDEA，去官网下载安装就行</li>
<li>注册以使用到2089年：<a href="https://app.yinxiang.com/Home.action?_sourcePage=ib8V5ZFRen_iMUD9T65RG_YvRLZ-1eYO3fqfqRu0fynRL_1nukNa4gH1t86pc1SP&__fp=R6Egp1Q_RAw3yWPvuidLz-TPR6I9Jhx8&hpts=1540264331333&showSwitchService=true&usernameImmutable=false&rememberMe=true&login=&login=%E7%99%BB%E5%BD%95&login=true&username=416361536%40qq.com&hptsh=V18ps1s5n4EhrRf2jdJ%2FuJBkiY4%3D#n=330b0d55-3f61-44b0-a3b7-8c8e2ac35e69&s=s53&ses=4&sh=2&sds=5&" target="_blank" rel="noopener">破解idea2019.3版本</a></li>
<li><a href="https://blog.csdn.net/weixin_40849588/article/details/96934259" target="_blank" rel="noopener">安装LeedCode插件</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/74783167" target="_blank" rel="noopener">一些快捷方式</a></li>
<li>方便的调试LeedCode题目：<ol>
<li>将LeedCode程序复制到Main中</li>
<li>通过函数调用的方法使用LeedCode程序</li>
</ol>
</li>
</ol>
</li>
<li><p>nvprof：</p>
<p>使用nvprof出现同步或者复制API占用时间最多时，有可能不是因为花费的时间多，而是因为在等待前面的操作执行完成</p>
</li>
<li><p>优化程序的方法：</p>
<ol>
<li>找到热点函数</li>
<li>确定热点函数的限制，比如上面说的寄存器使用数量，或者内存的带宽等等</li>
<li>找到与限制相关的瓶颈</li>
<li>确定限制在源码中的位置</li>
<li>用相关的方法去优化</li>
<li>重复上面的步骤</li>
</ol>
<p>首先应该学习一些相关的知识，才能够理解限制、产生限制的因素以及解决方法</p>
</li>
<li><p>改进：当没有学习动力的时候</p>
<ol>
<li>原因：时间短但当前任务耗费的时间和精力比较多且难度较大</li>
<li>方法：<ol>
<li>看书的一小节内容</li>
<li>完成TODO列表中的任务</li>
<li>做网课作业</li>
</ol>
</li>
</ol>
</li>
</ol>
<hr>
<h1 id="03-16："><a href="#03-16：" class="headerlink" title="03/16："></a>03/16：</h1><h3 id="第69天：这几天还是在看Nvidia的博客，使用新的方法之后，效果还是很不错的，不过前两天在外面玩，所以没有什么收获"><a href="#第69天：这几天还是在看Nvidia的博客，使用新的方法之后，效果还是很不错的，不过前两天在外面玩，所以没有什么收获" class="headerlink" title="第69天：这几天还是在看Nvidia的博客，使用新的方法之后，效果还是很不错的，不过前两天在外面玩，所以没有什么收获"></a>第69天：这几天还是在看Nvidia的博客，使用新的方法之后，效果还是很不错的，不过前两天在外面玩，所以没有什么收获</h3><h3 id="关键字：学习方法、运维连接服务器、向量化内存访问、查看CUDA汇编、CUDA流"><a href="#关键字：学习方法、运维连接服务器、向量化内存访问、查看CUDA汇编、CUDA流" class="headerlink" title="关键字：学习方法、运维连接服务器、向量化内存访问、查看CUDA汇编、CUDA流"></a>关键字：学习方法、运维连接服务器、向量化内存访问、查看CUDA汇编、CUDA流</h3><ol>
<li><p>学习方法：</p>
<ol>
<li>学习每一小节之前，先看目录预估会涉及哪些内容，然后大致浏览一遍，再回到目录看讲了哪些内容，然后再仔细进行阅读</li>
<li>每天进行总结，看有哪些收获</li>
<li>对于引言，大概浏览一遍，知道书中的重点是什么就行，看书应该快慢结合</li>
<li>在放纵一段时间之后，不一定要马上接着之前的任务做，可以做一些比较简单的，我感兴趣的任务，刷题就很不错</li>
</ol>
</li>
<li><p>运维连接服务器：</p>
<ol>
<li><p>使用跳板机</p>
</li>
<li><p>使用zerotier</p>
<p>zerotier：相当于是一个跳板机，不过省略了中间登录的步骤，并且相对于自己的跳板机来说更稳定一些</p>
</li>
<li><p>使用vpn</p>
</li>
<li><p>多个服务器</p>
</li>
</ol>
</li>
<li><p>向量化内存访问：</p>
<ol>
<li><p>使用方法：很简单</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">temp = <span class="keyword">reinterpret_cast</span>&lt;float2*&gt;(init)[index].x;</span><br><span class="line"><span class="keyword">reinterpret_cast</span>&lt;float2*&gt;(result)[index].x = temp;</span><br><span class="line"><span class="keyword">reinterpret_cast</span>&lt;float2*&gt;(result)[index].y = <span class="keyword">reinterpret_cast</span>&lt;float2*&gt;(init)[index].y;</span><br></pre></td></tr></table></figure>

<p>其中”reinterpret_cast“是在有数组偏移量的时候使用的，如果是单个数据，那么就可以直接使用</p>
</li>
<li><p>不过没有使用成功</p>
</li>
</ol>
</li>
<li><p>查看CUDA的汇编语言形式</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cuobjdump -sass <span class="built_in">exec</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>CUDA流：</p>
<ol>
<li><p>具体的使用方法网上有很多</p>
</li>
<li><p>理解：</p>
<ol>
<li><p>通过使用CUDA流可以手动创建流水线</p>
<p><img src="https://raw.githubusercontent.com/Pipepw/FigureBed/master/blog_files/img/PicGo-Github-PicBed/image-20200316231310632.png" alt="image-20200316231310632"></p>
</li>
<li><p>在流中的操作是顺序执行的，不同的流之间是并行的，所有流相对于主机是异步的</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<hr>
<h1 id="03-13"><a href="#03-13" class="headerlink" title="03/13:"></a>03/13:</h1><h3 id="第66天：这几天还是在看Nvidia的博客，不过效率很低，尝试新的方法，希望有好的效果"><a href="#第66天：这几天还是在看Nvidia的博客，不过效率很低，尝试新的方法，希望有好的效果" class="headerlink" title="第66天：这几天还是在看Nvidia的博客，不过效率很低，尝试新的方法，希望有好的效果"></a>第66天：这几天还是在看Nvidia的博客，不过效率很低，尝试新的方法，希望有好的效果</h3><hr>
<p>==已分类==</p>
<h1 id="03-11："><a href="#03-11：" class="headerlink" title="03/11："></a>03/11：</h1><h3 id="第64天：今天一直在看-Nvidia官方的博客-，还是有很大的收获的，不过博客的很多内容是开发者文档中有的，不过之后可以看一下开发者文档"><a href="#第64天：今天一直在看-Nvidia官方的博客-，还是有很大的收获的，不过博客的很多内容是开发者文档中有的，不过之后可以看一下开发者文档" class="headerlink" title="第64天：今天一直在看==Nvidia官方的博客==，还是有很大的收获的，不过博客的很多内容是开发者文档中有的，不过之后可以看一下开发者文档"></a>第64天：今天一直在看==Nvidia官方的博客==，还是有很大的收获的，不过博客的很多内容是开发者文档中有的，不过之后可以看一下开发者文档</h3><h3 id="关键字：-1"><a href="#关键字：-1" class="headerlink" title="关键字："></a>关键字：</h3><ol>
<li><p>使用nvprof：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nvprof --<span class="built_in">print</span>-gpu-trace ./nbody</span><br><span class="line"><span class="comment"># 其实使用 nvprof ./nbody 就行了，不过信息没那么详细</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>指定GPU的注意事项：</p>
<p>如果指定GPU在omp的外面，那么omp里面的线程就会在GPU0上运行，可能与设定的不一样，从而导致存储的内存与使用内存的不在同一个设备上，造成错误或降低性能</p>
</li>
<li><p>Tail Effect：</p>
<p>一个GPU通过grid执行kernel函数，一个grid又分成很多block来执行，而能使用的block数量是由SM的数量以及每个SM上block的数量决定的，Testla P100 有56个SM，每个SM上有32个Block，所以一共有56*32=1792个block，如果我一共调用2000个block，那么就会多出来一部分block在下一次运行，这样的话，第一次运行每个线程分配到的资源较少，导致速度变慢，所以可以通过使用__launch_bounds__来设置最大threads和最大block，不过如果很多的话，那么多出来的那一点点也没有啥影响</p>
<p>__launch_bounds__的使用方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__global__ <span class="keyword">void</span></span><br><span class="line">__launch_bounds__(maxThreadsPerBlock, minBlocksPerMultiprocessor)</span><br><span class="line">MyKernel(...)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>一些nvcc的编译选项：</p>
<ol>
<li>查看寄存器的使用：加上编译选项：-Xptxas -v</li>
<li>控制线程使用的最大寄存器数：加上编译选项：-maxrregcount=N</li>
</ol>
</li>
<li><p>occupancy：</p>
<ol>
<li>寄存器资源是有限的，如果一个线程使用过多的编译器，那么就会导致其他线程变慢，要使GPU有100%的occupancy，假设每个SM有65536个寄存器，64个warps，那么每个线程最多使用的寄存器数为65536/64/322=32个</li>
<li>除了寄存器的资源，还有共享内存的资源，也是同样的道理</li>
<li>如何计算occupancy：<ol>
<li>利用CUDA工具包里的那个excel就行</li>
</ol>
</li>
</ol>
</li>
<li><p>合并访问：</p>
<p>当相邻的线程读取相邻的数据时，就会合并到一起进行访问，从而提高性能</p>
</li>
</ol>
<h3 id="规划："><a href="#规划：" class="headerlink" title="规划："></a>规划：</h3><hr>
<h1 id="03-10："><a href="#03-10：" class="headerlink" title="03/10："></a>03/10：</h1><h3 id="第63天：这几天都在折腾cudaArray相关的事情，不过没有什么进展，一直都有错误"><a href="#第63天：这几天都在折腾cudaArray相关的事情，不过没有什么进展，一直都有错误" class="headerlink" title="第63天：这几天都在折腾cudaArray相关的事情，不过没有什么进展，一直都有错误"></a>第63天：这几天都在折腾cudaArray相关的事情，不过没有什么进展，一直都有错误</h3><h3 id="关键字：控制L1和共享缓存的使用量、CUDA错误、解决问题的步骤、使用nvvp出现权限不足的问题、-restrict-限定、一些内存的最大值、使用cudaArrary的反思、cudaCreateChannelDesc、机场、gnome-panel、使用surface-cudaArary"><a href="#关键字：控制L1和共享缓存的使用量、CUDA错误、解决问题的步骤、使用nvvp出现权限不足的问题、-restrict-限定、一些内存的最大值、使用cudaArrary的反思、cudaCreateChannelDesc、机场、gnome-panel、使用surface-cudaArary" class="headerlink" title="关键字：控制L1和共享缓存的使用量、CUDA错误、解决问题的步骤、使用nvvp出现权限不足的问题、__restrict__限定、一些内存的最大值、使用cudaArrary的反思、cudaCreateChannelDesc、机场、gnome-panel、使用surface cudaArary"></a>关键字：控制L1和共享缓存的使用量、CUDA错误、解决问题的步骤、使用nvvp出现权限不足的问题、__restrict__限定、一些内存的最大值、使用cudaArrary的反思、cudaCreateChannelDesc、机场、gnome-panel、使用surface cudaArary</h3><ol>
<li><p>控制L1和共享缓存的使用量（L1缓存和共享缓存使用相同的硬件资源）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span> <span class="title">T</span> &gt;</span></span><br><span class="line"><span class="class">__<span class="title">host__</span> <span class="title">cudaError_t</span> <span class="title">cudaFuncSetCacheConfig</span> ( <span class="title">T</span>* <span class="title">func</span>, <span class="title">cudaFuncCache</span> <span class="title">cacheConfig</span> ) 的使用方法：<span class="title">func</span> 就是函数的指针，<span class="title">cacheConfig</span> 有三个选项：</span></span><br><span class="line"><span class="class"><span class="title">cudaFuncCachePreferNone</span>:</span> <span class="function">no preference <span class="keyword">for</span> shared memory <span class="keyword">or</span> <span class="title">L1</span> <span class="params">(<span class="keyword">default</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">cudaFuncCachePreferShared: prefer larger shared memory <span class="keyword">and</span> smaller L1 cache</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">cudaFuncCachePreferL1: prefer larger L1 cache <span class="keyword">and</span> smaller shared memory </span></span><br><span class="line">#如果不指定函数的话，则是对所有的kernel函数有效，如：	(在cu文件的第一个函数中调用)</span><br><span class="line">cudaDeviceSetCacheConfig(cudaFuncCachePreferL1);</span><br><span class="line">#否则就是对单个kernel函数有效，如：</span><br><span class="line">cudaFuncSetCacheConfig(fooKernel, cudaFuncCachePreferL1);</span><br></pre></td></tr></table></figure>
</li>
<li><p>CUDA错误：</p>
<ol>
<li><p>"invalid configuration argument" on CUDA API call to cudaLaunchKernel：</p>
<p>看错误信息问题就知道是出在kernel函数的启动部分，未知的参数是因为线程分配出现错误，线程块中的线程超过了最大范围</p>
</li>
<li><p>"unspecified launch failure" on CUDA API call to cudaDeviceSynchronize：</p>
<p>把同步语句去掉就行了，不知道为什么</p>
</li>
<li><p>Unknown Error：</p>
<p>我真的不知道为什么</p>
</li>
<li><p>invalid argument:</p>
<p>函数的参数不对，也就是定义的地方、声明的地方以及调用的地方不匹配</p>
</li>
</ol>
</li>
<li><p>解决问题的步骤：</p>
<p>遇到错误之后，首先定位错误发生在什么地方，然后理解一下错误是什么，可能的原因是什么，看一下错误附近的代码，最后才是去找资料</p>
</li>
<li><p>使用nvvp出现权限不足的问题，首先按照它给的那个网站的方法进行修改，如果还是不行，则：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Sorry for inconvenience. Can you please try below steps, assuming you are on Linux?</span><br><span class="line"></span><br><span class="line">1. Create &lt;filename&gt;.conf file (e.g. profile.conf) in folder &#x2F;etc&#x2F;modprobe.d</span><br><span class="line">2. Open file &#x2F;etc&#x2F;modprobe.d&#x2F;profile.conf in any editor</span><br><span class="line">3. Add below line in profile.conf</span><br><span class="line">options nvidia &quot;NVreg_RestrictProfilingToAdminUsers&#x3D;0&quot;</span><br><span class="line">4. Close file &#x2F;etc&#x2F;modprobe.d&#x2F;profile.conf</span><br><span class="line">5. Restart your machine</span><br><span class="line"></span><br><span class="line">Also note that</span><br><span class="line"></span><br><span class="line">[1] On some systems, it may be necessary to rebuild the initrd after writing a configuration file to &#x2F;etc&#x2F;modprobe.d</span><br><span class="line">[2] On Ubuntu systems, when installing via the distro-native packages, the kernel module gets</span><br><span class="line">renamed from nvidia to nvidia-xxx, and then nvidia is aliased to nvidia-xxx</span><br><span class="line">(where xxx is the major number of the driver. So a 418.67 driver would use nvidia-418)</span><br></pre></td></tr></table></figure>
</li>
<li><p>__restrict__限定：</p>
<ol>
<li><p>作用：提高性能</p>
</li>
<li><p>原理：C++中将指针标注为<strong>restrict</strong>是告诉编译器这个指针不会被其他指针读取，而GPU的kernel函数用这个修饰符，则可以使用纹理缓存的通道（因为可以保证不会被其他指针修改，所以相对这个指针来说就是不变的）</p>
</li>
<li><p>使用方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">float</span>* __restrict__ input, <span class="keyword">float</span>* __restrict__ output</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>一些内存的最大值：</p>
<p><img src="https://raw.githubusercontent.com/Pipepw/FigureBed/master/blog_files/img/PicGo-Github-PicBed/image-20200310181437823.png" alt="image-20200310181437823"></p>
</li>
<li><p>使用cudaArrary的反思:</p>
<ol>
<li>当你认为存在什么问题时，那么就应该先解决这个问题，至少也要进行一番考</li>
<li>如果要改动的地方特别多，那么应该现在例程中继续测试，避免做无用功</li>
<li>读文档的时候，要仔细一些，特别关注一些限制之类的，也是避免做无用功</li>
<li>找资料（特别是一些关于应用的资料），比如这次找cudaArray相关的用法的资料，首先应该找博客，看一下是怎样使用的，有个大致的了解，如果还存在问题的话，就搜索里面用到的一些函数，这样会有更具体的资料，还有就是看官方文档</li>
<li>出错之后先不要着急去找资料，解决问题的第一步是理解问题，比如之间遇到的“invalid argument”错误，明显是参数错误了，但是我没有进行更深入的思考，更没有结合代码进行思考，导致浪费了许多时间去找没用的资料</li>
<li>调试的正确顺序：先使用cuda-memcheck检查是否发生内存错误，然后使用cuda-gdb进行定位</li>
</ol>
</li>
<li><p>cudaCreateChannelDesc：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//For float texels we could create a channel with;</span></span><br><span class="line">              cudaCreateChannelDesc( <span class="number">32</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, cudaChannelFormatKindFloat );</span><br><span class="line"><span class="comment">//While for short4 texels this would be</span></span><br><span class="line">             cudaCreateChannelDesc( <span class="number">16</span>, <span class="number">16</span>, <span class="number">16</span>, <span class="number">16</span>, cudaChannelFormatKindSigned );</span><br></pre></td></tr></table></figure>
</li>
<li><p>机场</p>
<blockquote>
<p><strong>测速图Telegram频道：</strong><a href="https://t.me/DuyaoSS" target="_blank" rel="noopener">https://t.me/DuyaoSS</a>     </p>
<p><strong>主用链接：</strong><a href="https://www.duyaoss.com/archives/3/" target="_blank" rel="noopener">DuyaoSS-毒药机场简介博客</a>  </p>
<p><strong>备用链接：</strong> <a href="http://387099.blogspot.com/2018/03/ssssr.html?m=1" target="_blank" rel="noopener">Blogger博客</a>  </p>
<p><strong><a href="https://github.com/DuyaoSS/SSR/issues/1" target="_blank" rel="noopener">Github备用帖（国内可访问）</a></strong>  </p>
<p><strong>上海电信测速：</strong><a href="https://www.duyaoss.com/archives/1/" target="_blank" rel="noopener">浅谈部分机场（SS/SSR提供商）--电信纯测速图版</a>  </p>
<p><strong>江苏移动测速：</strong><a href="https://www.duyaoss.com/archives/1031/" target="_blank" rel="noopener">浅谈部分机场（SS/SSR提供商）--移动纯测速图版</a> </p>
<p><a href="https://www.duyaoss.com/archives/57/" target="_blank" rel="noopener">SS机场常用服务器线路微普及--慢慢填充</a> </p>
<p><a href="https://www.duyaoss.com/archives/1086/" target="_blank" rel="noopener">一份不负责任的机场使用手册（内含SS/SSR客户端下载）</a> </p>
<p><a href="https://union.115.com/?ac=space_seal_list&share_code=22d1e7a7d2b2f1a8867d655b3cb49cc8#" target="_blank" rel="noopener">115网盘办理（450元1年）</a></p>
</blockquote>
</li>
<li><p>gnome-panel：可以在shell启动软件的UI版本，远程接入的时候</p>
</li>
<li><p>使用surface cudaArary：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">cudaChannelFormatDesc channelDesc = cudaCreateChannelDesc(<span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>, cudaChannelFormatKindUnsigned);</span><br><span class="line"></span><br><span class="line"><span class="comment">//point surface memory</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cudaResourceDesc</span> <span class="title">resDesc</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;resDesc,<span class="number">0</span>,<span class="keyword">sizeof</span>(resDesc);</span><br><span class="line">    resDesc.resType = cudaResourceTypeArray;</span><br><span class="line"><span class="comment">//create surface object</span></span><br><span class="line">    resDesc.res.<span class="built_in">array</span>.<span class="built_in">array</span> = real;</span><br><span class="line">    cudaSurfaceObject_t inputSurfObj = <span class="number">0</span>;</span><br><span class="line">    cudaCreateSurfaceObject(&amp;real, &amp;resDesc);</span><br><span class="line">    resDesc.res.<span class="built_in">array</span>.<span class="built_in">array</span> = imag;</span><br><span class="line">    cudaSurfaceObject_t inputSurfObj = <span class="number">0</span>;</span><br><span class="line">    cudaCreateSurfaceObject(&amp;imag, &amp;resDesc);</span><br></pre></td></tr></table></figure>



</li>
</ol>
<hr>
<h1 id="02-28："><a href="#02-28：" class="headerlink" title="02/28："></a>02/28：</h1><h3 id="第51天："><a href="#第51天：" class="headerlink" title="第51天："></a>第51天：</h3><ol>
<li>主要是在GPU内存方向进行努力：全局内存、本地内存、共享内存、常量内存、纹理内存、只读缓存，零拷贝内存不过这些对于QuEST的优化好像都没有什么帮助</li>
<li>理解GPU的架构</li>
</ol>
<h3 id="关键字：共享内存、常量内存、只读缓存、全局内存、纹理内存、一级缓存、SM加载数据的三种路径、优化设备内存带宽利用率的两个目标、nvprof、添加快捷方式到开始菜单、如何使用共享内存"><a href="#关键字：共享内存、常量内存、只读缓存、全局内存、纹理内存、一级缓存、SM加载数据的三种路径、优化设备内存带宽利用率的两个目标、nvprof、添加快捷方式到开始菜单、如何使用共享内存" class="headerlink" title="关键字：共享内存、常量内存、只读缓存、全局内存、纹理内存、一级缓存、SM加载数据的三种路径、优化设备内存带宽利用率的两个目标、nvprof、添加快捷方式到开始菜单、如何使用共享内存"></a>关键字：共享内存、常量内存、只读缓存、全局内存、纹理内存、一级缓存、SM加载数据的三种路径、优化设备内存带宽利用率的两个目标、nvprof、添加快捷方式到开始菜单、如何使用共享内存</h3><ol>
<li><p>共享内存：</p>
<ol>
<li>位置：共享内存为片上内存，所以延迟比一般的变量低的多，使用起来就是避免多次从本地内存中进行获取</li>
<li>特点：对同一线程块中的线程可见，而其他线程块不可见</li>
<li>使用：声明一个线程块大小的共享数组，每个线程中可对其进行访问（__shared__)</li>
<li>适用：在同一线程块中的线程有交换数据的需要的时候</li>
</ol>
</li>
<li><p>常量内存：</p>
<ol>
<li><p>位置：位于显存，但是在片上有缓存（片上缓存与一级缓存和共享内存类似）</p>
</li>
<li><p>特点：</p>
<ol>
<li>在主机中可进行修改，在kernel中为只读</li>
<li>GPU每次把单次常量内存的读取操作广播到半个线程束</li>
<li>每个SM只有64kb</li>
</ol>
</li>
<li><p>使用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cudaMemcpyToSymbol(s, temps, <span class="keyword">sizeof</span>(Sphere)*SPHERES);</span><br><span class="line"><span class="comment">//通过这个将其放到常量内存空间中</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>适用：在kernel中只读</p>
</li>
</ol>
</li>
<li><p>只读缓存：</p>
<ol>
<li><p>位置：位于片上，和一级缓存类似（不过粒度更细）</p>
</li>
<li><p>特点：</p>
<ol>
<li>只读缓存独立存在，区别于常量缓存，常量缓存喜欢小数据，而只读内存加载的数据比较大</li>
<li>可以在非统一模式下访问</li>
<li>统一访问（读取同一地址）</li>
<li>每个SM上有48kb</li>
<li>有从全局内存的专用带宽</li>
</ol>
</li>
<li><p>使用：</p>
<ol>
<li><p>使用函数 _ldg</p>
</li>
<li><p>在间接引用的指针上使用__restrict__限定修饰符</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__global__ <span class="keyword">void</span> <span class="title">copyKernel</span><span class="params">(<span class="keyword">float</span> * in,<span class="keyword">float</span>* out)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> idx=blockDim*blockIdx.x+threadIdx.x;</span><br><span class="line">    out[idx]=__ldg(&amp;amp;in[idx]);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kernel</span><span class="params">(<span class="keyword">float</span>* output, <span class="keyword">const</span> <span class="keyword">float</span>* __restrict__ input)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">output[idx] += input[idx];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>适用：未知</p>
</li>
</ol>
</li>
<li><p>全局内存：</p>
<ol>
<li>位置：位于显存</li>
<li>特点：<ol>
<li>GPU和CPU都可以对其进行访问(在主机端通过cudaMalloc进行分配)</li>
<li>使用对齐且连续的方式进行访问，则可以将大量的内存获取请求合并，达到减少内存获取次数的结果</li>
</ol>
</li>
<li>常规就是全局内存</li>
</ol>
</li>
<li><p>纹理内存：</p>
<ol>
<li>位置：纹理存储器中的数据以一维、二维或者三维数组的形式存储在显存中，常量内存一样缓存在芯片上</li>
<li>特点：<ol>
<li>只读</li>
<li>以通过缓存加速访问，并且可以声明的大小比常数存储器要大得多</li>
<li>可绑定的数据有两种：<ol>
<li>普通的线性存储器（通过cudaMalloc()进行声明的一段连续的线性内存空间）</li>
<li>CUDA数组（通过cudaMallocArray()进行声明的线性对齐的内存空间）</li>
</ol>
</li>
</ol>
</li>
<li>适用：需要交叉访问内存</li>
</ol>
</li>
<li><p>一级缓存：</p>
<ol>
<li><p>核函数运行时需要从全局内存（DRAM）中读取数据，只有两种粒度</p>
<ol>
<li>128字节</li>
<li>32字节</li>
</ol>
</li>
<li><p>由访问方式决定的：</p>
<ol>
<li>使用一级缓存—128字节 </li>
<li>不使用一级缓存—32字节</li>
</ol>
</li>
<li><p>操作：适用flag禁用或启用L1 cache</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-Xptxas -dlcm=cg	<span class="comment">#禁用</span></span><br><span class="line">-Xptxas -dlcm=ca	<span class="comment">#启用</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>SM加载数据的三种路径：</p>
<ol>
<li>L1和L2Cache</li>
<li>常量缓存</li>
<li>只读缓存</li>
</ol>
</li>
<li><p>优化设备内存带宽利用率的两个目标：</p>
<ol>
<li>对齐合并内存访问，减少带宽的浪费（这个在QuEST中好像没有办法）</li>
<li>足够的并发内存操作，隐藏内存延迟：<ol>
<li>增加每个线程中执行独立内存操作的数量（展开技术）</li>
<li>对核函数启动的执行配置进行试验，以充分体现每个SM的并行性（增大并行性）</li>
<li>延迟：<ol>
<li>算术指令延迟：从开始运算到运算结束之间的时间，只有用于运算的单元处于工作状态，而其他逻辑单元则是空闲状态</li>
<li>内存指令延迟：当访问内存的时候，计算单元要等数据从内存取到寄存器</li>
</ol>
</li>
<li>延迟隐藏：将空闲的单元给其他线程使用</li>
</ol>
</li>
<li>优化内存的方法：<ol>
<li>对齐内存访问：一个内存事务的首个访问地址是缓存粒度的偶数倍</li>
<li>合并内存访问：一个线程束内的线程访问都在一个内存块里面</li>
</ol>
</li>
</ol>
</li>
<li><p>nvprof：</p>
<ol>
<li><p>分析程序执行过程：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvprof --metrics branch_efficiency ./demo</span><br></pre></td></tr></table></figure>
</li>
<li><p>考察事件计数器：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvprof --events branch,divergent_branch ./demo</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>添加快捷方式到开始菜单：</p>
<p>1.将程序的快捷方式复制或者拖入一下目录中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\ProgramData\Microsoft\Windows\Start Menu\Programs</span><br></pre></td></tr></table></figure>

<p>2.拖进去之后，点开开始菜单会在左侧程序中找到该快捷方式，再右键->选择“固定在开始菜单中</p>
</li>
<li><p>如何使用共享内存：</p>
<ol>
<li>需要注意的是，不要只关注这一个线程中的操作</li>
<li>声明一个共享内存数组，在每个线程中将其赋值为需要计算的数组（如果这样做的话，也不是很多，每个线程只做一步，但是可能内存不够，或者共享内存不够）</li>
<li>需要注意的是，共享内存是在一个block中进行共享的，所以每个block都需要单独声明</li>
</ol>
</li>
</ol>
<hr>
<h1 id="02-26："><a href="#02-26：" class="headerlink" title="02/26："></a>02/26：</h1><h3 id="第49天："><a href="#第49天：" class="headerlink" title="第49天："></a>第49天：</h3><ol>
<li>使用多GPU失败，不过过程中学到了不少东西</li>
<li>理解GPU的架构</li>
<li>开始尝试CUDA优化，不过没有什么效果</li>
<li>学习使用cuda-gdb进行调试</li>
</ol>
<h3 id="关键字：神经网路相关、零拷贝内存、P2P复制、使用nvcc编译、同步、检查CUDA错误、使用gdb进行调试、CUDA的一些细节、使用cuda-gdb、GPU架构、思想"><a href="#关键字：神经网路相关、零拷贝内存、P2P复制、使用nvcc编译、同步、检查CUDA错误、使用gdb进行调试、CUDA的一些细节、使用cuda-gdb、GPU架构、思想" class="headerlink" title="关键字：神经网路相关、零拷贝内存、P2P复制、使用nvcc编译、同步、检查CUDA错误、使用gdb进行调试、CUDA的一些细节、使用cuda-gdb、GPU架构、思想"></a>关键字：神经网路相关、零拷贝内存、P2P复制、使用nvcc编译、同步、检查CUDA错误、使用gdb进行调试、CUDA的一些细节、使用cuda-gdb、GPU架构、思想</h3><ol>
<li><p>神经网络相关</p>
<ol>
<li>感知机：有若干输入和一个输出，一个感知机就对应一个函数，处理输入，得到输出</li>
<li>深度神经网络：包含三层：输入层，隐藏层、输出层，可以有多个输出，内部由多个感知机组成</li>
<li>卷积神经网络：卷积层：将输入不同局部的矩阵与卷积核进行矩阵运算，池化层：对矩阵进行压缩，有两种池化方法：平均池化和最大池化，具体的应用还需要看代码</li>
</ol>
</li>
<li><p>零拷贝内存：</p>
<ol>
<li><p>基础：使用页锁定内存，将使用的内存在CPU上进行锁定，使其一直存在在上面，从而使GPU可以直接继续进行使用</p>
</li>
<li><p>用处：</p>
<ol>
<li>当显存不够时可以用这种方法进行存储</li>
<li>因为是整块进行拷贝，所以可以加快CPU和GPU的数据传输速度</li>
</ol>
</li>
<li><p>局限性：</p>
<ol>
<li>在只有一次拷贝的数据上使用才有效果</li>
<li>增大CPU内存的使用</li>
</ol>
</li>
<li><p>使用方法：</p>
<ol>
<li><p>分配空间</p>
<p>cudaHostAlloc((void**)&x,sizeof(int),cudaHostAllocWriteCombined|cudaHostAllocMapped));</p>
<p>其中cudaHostAllocMapped标签表示使用零拷贝内存，cudaHostAllocWriteCombined表示使用合并式写入</p>
</li>
<li><p>使用分配的空间</p>
<p>cudaHostGetDevicePointer(&dev_x,x,0);表示将x的地址赋值给dev_x，这样就可以通过dev_x访问零拷贝内存的内容了</p>
<p>为什么不直接使用x呢？因为cudaHostAlloc()返回的是在CPU上的地址，在GPU上对应的地址是不一样的，所以需要赋值一个GPU指针</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>P2P复制</p>
<ol>
<li><p>启动</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cudaSetDevice(gpuid_0);</span><br><span class="line">cudaDeviceEnablePeerAccess(gpuid_1,<span class="number">0</span>);</span><br><span class="line">cudaSetDevice(gpuid_1);</span><br><span class="line">cudaDeviceEnablePeerAccess(gpuid_0, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cudaMemcpy(gpu0_buf, gpu1_buf, buf_size, cudaMemcpyDefault);</span><br><span class="line"><span class="comment">//因为使用了统一内存地址，所以直接使用Default就行，而不用指定方向</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>使用nvcc编译</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nvcc -Xcompiler -fopenmp omp_mCuda.cu <span class="comment">#编译omp</span></span><br><span class="line">-gencode=arch=compute_35,code=\"sm_35,compute_35\" <span class="comment">#指定GPU的计算能力</span></span><br><span class="line"><span class="comment">#不知道怎样指定使用icc或gcc</span></span><br></pre></td></tr></table></figure>

<p>因为nvcc编译时会使用额外的编译器来编译文件中的C或者C++部分，使用-Xcompiler就是设置额外编译器的flag</p>
</li>
<li><p>同步</p>
<ol>
<li><p>omp同步：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp barrier</span></span><br><span class="line"><span class="comment">//使所有线程都执行到这里再继续往后执行</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>CUDA同步：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cudaDeviceSynchronize();</span><br><span class="line"><span class="comment">//使一个GPU中的所有线程都完成任务之后再继续往后执行</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>检查CUDA错误：</p>
<p>Kernel调用出错的原因有很多，在Host端调用Kernel函数后，使用如下语句检查错误</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cudaError_t  error_check ;</span><br><span class="line"><span class="comment">//....</span></span><br><span class="line">kernel &lt;&lt;&lt; grid , block &gt;&gt;&gt; ( argument0 , argument1 , argument2 ,...... ) ;</span><br><span class="line">error_check = cudaGetLastError();</span><br><span class="line"><span class="keyword">if</span>( error_check != cudaSuccess )&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span> , cudaGetErrorString( error_check ) );</span><br><span class="line">    system(<span class="string">"pause"</span>) ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><pre><code class="bash">all CUDA-capable devices are busy or unavailable
<span class="comment">#我的原因是GPU0正在被占用，但是程序刚开始是默认使用GPU0，所以错误</span>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. &#96;&#96;&#96;bash</span><br><span class="line">   an illegal memory access was encountered</span><br><span class="line">   # 这个错误出现的原因是某个地方非法访问内存</span><br></pre></td></tr></table></figure></code></pre>
</li>
<li><p>使用这个方法只是告诉你程序的确有问题，具体的错误位置需要调试才行</p>
</li>
</ol>
</li>
<li><p>使用gdb进行调试：</p>
<ol>
<li><p>编译时加上-g参数 </p>
</li>
<li><p>使用gdb [可执行文件] 开始编译 </p>
</li>
<li><p>r 开始运行</p>
</li>
<li><p>start 执行到main的第一行</p>
</li>
<li><p>使用until结束循环</p>
</li>
<li><p>使用s 单步调试（会进入函数）</p>
</li>
<li><p>使用c 执行到断电</p>
</li>
<li><p>通过break设置断点</p>
</li>
<li><p>使用l列出源码，这样便于设置断点</p>
</li>
<li><p>使用n N可以执行N次下一步（不会进入函数）</p>
</li>
<li><p>使用where查看当前位置</p>
</li>
<li><p>在gdb中可以直接执行重新编译后的程序，所以不用每次都关掉重新打开，直接重新run就行了</p>
<ol>
<li><p>当只有一个终端时：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2.</span> ctrl + z <span class="comment">// 挂起GDB</span></span><br><span class="line"></span><br><span class="line">jobs     <span class="comment">// 查看VIM对应的作业号，假设为1</span></span><br><span class="line"></span><br><span class="line">fg %<span class="number">1</span>    <span class="comment">// 进入VIM，修改代码..</span></span><br><span class="line"></span><br><span class="line">ctrl + z <span class="comment">// 修改完后挂起VIM</span></span><br><span class="line"></span><br><span class="line">gcc -g -Wall -o insert_sort a.cpp <span class="comment">// 重新编译程序</span></span><br><span class="line"></span><br><span class="line">fg %<span class="number">2</span>    <span class="comment">// 进入GDB，假设GDB的作业号为2</span></span><br><span class="line">相关常用指令：</span><br><span class="line">fg %<span class="number">1</span>         <span class="comment">// 打开VIM，1是VIM对应的作业号</span></span><br><span class="line"></span><br><span class="line">fg %<span class="number">2</span>         <span class="comment">// 打开GDB</span></span><br><span class="line"></span><br><span class="line">bg %<span class="number">1</span>         <span class="comment">// 让VIM到后台运行</span></span><br><span class="line"></span><br><span class="line">kill %<span class="number">1</span> &amp;&amp; fg <span class="comment">// 彻底杀死VIM进程</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
</li>
<li><p>CUDA的一些细节：</p>
<ol>
<li><p>不能使用多个GPU访问同一个数组</p>
<ol>
<li>当使用omp并行执行多GPU时，会出现运行时错误</li>
<li>当在一个线程中串行启动多GPU时，其中一个GPU的结果会覆盖掉其他GPU的结果</li>
</ol>
</li>
<li><p>可以使用不同线程的同一个GPU访问同一个数组</p>
</li>
<li><p>使用printf的输出很可能是错的</p>
<ol>
<li><p>没有输出：</p>
<p>cudaDeviceReset();</p>
</li>
<li><p>输出的值与预测的不同：</p>
<p>重新写一个输出（虽然不知道为什么）</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>使用cuda-gdb：</p>
<p>基础操作和gdb是一样的，在其基础上进行了添加，需要使用-G使其能看到kernel函数的信息</p>
<p>在运行之前使用set cuda memchech on 打开cuda内存检查</p>
<p>使用 set cuda break_on_launchapplication 在每个kernel开始执行之前设置断点</p>
<p><img src="https://raw.githubusercontent.com/Pipepw/FigureBed/master/blog_files/img/PicGo-Github-PicBed/image-20200517083704948.png" alt="image-20200517083704948"></p>
<p><img src="https://raw.githubusercontent.com/Pipepw/FigureBed/master/blog_files/img/PicGo-Github-PicBed/image-20200225001215839.png" alt="image-20200225001215839"></p>
<p><img src="https://raw.githubusercontent.com/Pipepw/FigureBed/master/blog_files/img/PicGo-Github-PicBed/image-20200225001250427.png" alt="image-20200225001250427"></p>
<p><img src="https://raw.githubusercontent.com/Pipepw/FigureBed/master/blog_files/img/PicGo-Github-PicBed/image-20200225001331213.png" alt="image-20200225001331213"></p>
<p><img src="https://raw.githubusercontent.com/Pipepw/FigureBed/master/blog_files/img/PicGo-Github-PicBed/image-20200225001435048.png" alt="image-20200225001435048"></p>
<p><img src="https://raw.githubusercontent.com/Pipepw/FigureBed/master/blog_files/img/PicGo-Github-PicBed/image-20200225001824915.png" alt="image-20200225001824915"></p>
<p><img src="https://raw.githubusercontent.com/Pipepw/FigureBed/master/blog_files/img/PicGo-Github-PicBed/image-20200225001859867.png" alt="image-20200225001859867"></p>
<p><img src="https://raw.githubusercontent.com/Pipepw/FigureBed/master/blog_files/img/PicGo-Github-PicBed/image-20200225002014047.png" alt="image-20200225002014047"></p>
<p><img src="https://raw.githubusercontent.com/Pipepw/FigureBed/master/blog_files/img/PicGo-Github-PicBed/image-20200225002350927.png" alt="image-20200225002350927"></p>
</li>
</ol>
<ol start="10">
<li><p>GPU架构：</p>
<ol>
<li>由多个流式多处理器（SM）组成</li>
<li>SM中包含SP：进行整数（ALU）和浮点数（FPU）计算，SFU：快速函数计算，DPU：双精度计算，LSU：从内存读写数据的单元，包含计算地址的计算单元<br>与CPU进行比较：CPU只有一个或少数几个计算单元，而GPU中几乎每个部件都有独立的计算单元，GPU中没有控制单元，CPU中的控制单元用来决定指令执行的流程等，而GPU用来负责计算就行</li>
<li>warp是SM的基本执行单元，一个warp包含32个并行thread，一个warp中的线程执行相同的指令，如果一个warp的发生分支，那么另一个分支的线程会被执行当前分支的线程阻塞</li>
<li>每个SM有固定数量的shared memory和一定数量的寄存器（上千个），每个线程瓜分这些资源，资源限制了驻留在SM中block的数量，所以并不是 block都同时执行的</li>
<li>如果每个 thread 一次存取的数据并不是 32 bits、64 bits、或 128 bits，那就无法符合 coalesced 的条件.合并访问是指所有线程访问连续的对齐的内存块</li>
<li>组合整块数据传送要快于分小块多次传送</li>
</ol>
</li>
<li><p>思想：</p>
<blockquote>
<p>如果一个流程的最后结果是错误的，那么通行的解决方法是逐步骤调试，先保证每个环节都正常运行了，没有挂掉，没有越界什么的；再观察每步的结果，检查有没有逻辑问题。这样逐一排查，才能解决问题。而不是仅凭主观去猜测问题所在，主观猜测可以提供思路，但需要客观实测的结果来支持才可以</p>
<p>两个kernel之间当然可以插入一个普通的C函数，以及该函数当然可以做一些辅助的处理工作，配合适当的数据交换机制，host端结果当然可以被kernel继续使用的。但可以使用不代表您的实现是正确的，您没有检查自己实现的正确与否，而是始终质疑这个机制是否可行，这是不合适的，也是不解决问题的</p>
</blockquote>
</li>
</ol>
<hr>
<h1 id="02-19："><a href="#02-19：" class="headerlink" title="02/19："></a>02/19：</h1><h3 id="第42天："><a href="#第42天：" class="headerlink" title="第42天："></a>第42天：</h3><ol>
<li><p>融合门我使用失败，等之后看郭永强是怎样实现融合门的</p>
</li>
<li><p>前几天更多的是在重新理解QuEST的代码，充分说明了理解代码的重要性，刚开始也有理解代码，但是因为方法不对，所以没有什么收获，有什么不理解的地方，就去代码里面找，比如不知道数据是怎么存储的，就去初始化里面找，但是因为刚开始对代码不熟悉，所以也不知道该怎么去找</p>
</li>
<li><p>然后是开始做GPU上面的工作：</p>
<ol>
<li>将CPU的优化迁移到GPU上</li>
<li>优化GPU的代码</li>
<li>改为分布式GPU，多GPU运行</li>
</ol>
<p>我目前的主要工作是将代码改为多GPU运行，但是GPU的运行结果一直是错的，就很恼火</p>
</li>
</ol>
<h3 id="关键字：gdb调试、perf查看、-D参数、一些Linux命令、xshell访问内网服务器、多GPU编程、指定使用GPU"><a href="#关键字：gdb调试、perf查看、-D参数、一些Linux命令、xshell访问内网服务器、多GPU编程、指定使用GPU" class="headerlink" title="关键字：gdb调试、perf查看、-D参数、一些Linux命令、xshell访问内网服务器、多GPU编程、指定使用GPU"></a>关键字：gdb调试、perf查看、-D参数、一些Linux命令、xshell访问内网服务器、多GPU编程、指定使用GPU</h3><ol>
<li><p>gdb调试：</p>
<ol>
<li>编译时加上-g参数之后才可以使用gdb进行调试，具体的调试方法用到的时候再去查</li>
</ol>
</li>
<li><p>perf查看，a查看具体信息，同样也是用到的时候再去查</p>
</li>
<li><p>-D参数，cmake加上-D参数是对生成的CMakeLists.txt中的变量赋值，而makefile中的-D参数是加到flag上的，也就是最后是gcc加上-D参数是对程序中的宏变量赋值，并且这个变量刚开始是没有值的才行（也就是一般是用来进行判断的）</p>
</li>
<li><p>一些Linux命令：</p>
<ol>
<li>pidof 查看进程id</li>
<li>ps 查看进程状态，常用ps aux，a表示所有进程，u表示以用户为主的格式来显示，x表示显示所有程序，不以终端机来区分，之后一般要加筛选信息，ps aux | grep apt，其中"|"表示管道，grep表示筛选</li>
<li>这两个结合起来是用来查看进程id的，一般是用 ps aux | grep [progress name] 来找到符合的几个进程，然后通过pidof查看需要进程的id，ps可以列出多个，pidof只有一个</li>
</ol>
</li>
<li><p>xshell访问内网服务器：</p>
<ol>
<li><p>正规方法是设置隧道之类的</p>
</li>
<li><p>方便的方法则是设置登陆脚本，这样还可以进行套娃操作</p>
<p><img src="https://raw.githubusercontent.com/Pipepw/FigureBed/master/blog_files/img/PicGo-Github-PicBed/image-20200220111255446.png" alt="image-20200220111255446"></p>
</li>
</ol>
</li>
<li><p>多GPU编程：</p>
<ol>
<li>主线程用cudaSetDevice()函数切换不同的GPU </li>
<li>Linux下使用pthread实现多GPU </li>
<li>OPENMP </li>
<li>MPI </li>
<li>GPU虚拟化</li>
<li>具体的实现需要继续查找资料，并且从中挑选出需要修改代码最少的方法来优化</li>
</ol>
</li>
<li><p>指定使用GPU：</p>
<ol>
<li><p>在运行时使用CUDA_VISIBLE_DEVICES指定使用的GPU</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CUDA_VISIBLE_DEVICES=1,0 ./demo</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ol>
<h3 id="接下来的工作："><a href="#接下来的工作：" class="headerlink" title="接下来的工作："></a>接下来的工作：</h3><ol>
<li>检查有没有出错的地方</li>
<li>将GPU改为2精度</li>
<li>问一下郭永强的融合门是怎么实现的</li>
<li>将CPU的优化迁移到GPU上</li>
<li>查找GPU的优化方法</li>
</ol>
<hr>
<h1 id="02-13："><a href="#02-13：" class="headerlink" title="02/13："></a>02/13：</h1><h3 id="第36天：今天还是在看门融合相关的代码，不过主要是为了移植到QuEST上，这几天读代码，可以看出我的方法有很大的问题，导致读代码的效率十分低下"><a href="#第36天：今天还是在看门融合相关的代码，不过主要是为了移植到QuEST上，这几天读代码，可以看出我的方法有很大的问题，导致读代码的效率十分低下" class="headerlink" title="第36天：今天还是在看门融合相关的代码，不过主要是为了移植到QuEST上，这几天读代码，可以看出我的方法有很大的问题，导致读代码的效率十分低下"></a>第36天：今天还是在看门融合相关的代码，不过主要是为了移植到QuEST上，这几天读代码，可以看出我的方法有很大的问题，导致读代码的效率十分低下</h3><h3 id="关键字：电脑开热点、磁盘格式化、提高效率、怎样读代码、三级缓存、模板、关键字"><a href="#关键字：电脑开热点、磁盘格式化、提高效率、怎样读代码、三级缓存、模板、关键字" class="headerlink" title="关键字：电脑开热点、磁盘格式化、提高效率、怎样读代码、三级缓存、模板、关键字"></a>关键字：电脑开热点、磁盘格式化、提高效率、怎样读代码、三级缓存、模板、关键字</h3><ol>
<li><p>电脑开热点：</p>
<p>手机连接时一直显示获取ip，并且ip配置失败，这时需要将手机的ip有DHCP设置为静态，其中ip地址就是路由器地址的前三个，第四个为1-255并且不能被其他设备使用，这个可以自己设置，路由器就是电脑上分配的ip，其余的按照默认就好</p>
</li>
<li><p>磁盘格式化：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> df -h  <span class="comment">#查看已挂载硬盘信息</span></span><br><span class="line"></span><br><span class="line">fdisk -l   <span class="comment">#查看磁盘信息，未挂载的也会列出来</span></span><br><span class="line"></span><br><span class="line">fdisk /dev/xvdb  <span class="comment">#对数据盘进行分区，回车之后，继续 根据提示，依次输入”n” ,”p”,“1”,两次回车，“wq”, 分区就开始了，很快就会完成</span></span><br><span class="line"></span><br><span class="line">mkfs .ext3 /dev/xvdb1  <span class="comment">#命令对新分区进行格式化</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> ‘/dev/xvdb1  /opt/store  ext3    defaults    0  0′ &gt;&gt; /etc/fstab   <span class="comment">#添加分区信息</span></span><br><span class="line"></span><br><span class="line">mount -a  <span class="comment">#命令挂载新分区</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>提高效率：</p>
<ol>
<li>将自己的想法以及思考过程记录下来</li>
<li>番茄工作法</li>
<li>用时间块记录时间和事情</li>
<li>记录零碎的事情</li>
<li>每天晚上做总结以及做第二天的规划</li>
<li>休息的时候就走动一下，锻炼一下身体之类的吧</li>
</ol>
</li>
<li><p>怎样读代码：</p>
<ol>
<li>追根溯源，找到最开始的定义</li>
<li>注意变量的作用域，来自哪里，遇到不知道的多去查一下</li>
<li>注意变量以及函数的名称有可能与作用相同，但不能过于相信，不然会被误导</li>
<li>深度优先的方式递归</li>
<li>有些地方实在看不懂的时候，将那部分提取出来单独调试</li>
<li>不要太过注意细节，只关注自己想要得到的信息，无关信息和代码可以跳过</li>
</ol>
</li>
<li><p>三级缓存：</p>
<ol>
<li>一级缓存：<br>一级缓存是内置在CPU内部的，一级缓存分为一级数据缓存和一级指令缓存，一级数据缓存中存放的是常用的数据，一级指令缓存中存放的是利用这些数据的指令，这样就可以减少争用Cache所造成的冲突了，从而提高处理器性能，通常一级数据缓存和一级指令缓存具有相同的容量</li>
<li>二级缓存：<br>作用是解决一级缓存与内存之间速度差距过大的问题，是一级缓存和内存之间数据临时交换的地方</li>
</ol>
</li>
<li><p>模板：</p>
<p>​    尖括号中表示的是占位符的名称，也就是后面实际调用的时候，使用的是什么类型就替换为具体的什么类型</p>
</li>
<li><p>关键字：</p>
<ol>
<li>nodiscard：表示不应该忽视函数的返回值</li>
<li>constexpr：生成常量表达式，也就是将模板在编译时转换为具体的函数，这样有提高程序的性能，需要函数足够简单才行</li>
<li>都是在声明中进行使用</li>
</ol>
</li>
</ol>
<h3 id="明天："><a href="#明天：" class="headerlink" title="明天："></a>明天：</h3><ol>
<li>看一下量子计算程序的理论部分，预计时间两4个番茄</li>
<li>动手修改代码<ol>
<li>搞清楚底层的实现方式</li>
<li>一一对应、移植</li>
</ol>
</li>
</ol>
<hr>
<h1 id="02-12："><a href="#02-12：" class="headerlink" title="02.12："></a>02.12：</h1><h3 id="第35天：效率十分低下，做的事情主要是查看量子融合门相关的代码"><a href="#第35天：效率十分低下，做的事情主要是查看量子融合门相关的代码" class="headerlink" title="第35天：效率十分低下，做的事情主要是查看量子融合门相关的代码"></a>第35天：效率十分低下，做的事情主要是查看量子融合门相关的代码</h3><h3 id="关键字：size-t和size-type、元组"><a href="#关键字：size-t和size-type、元组" class="headerlink" title="关键字：size_t和size_type、元组"></a>关键字：size_t和size_type、元组</h3><ol>
<li><p>size_t和 size_type</p>
<pre><code>size_t在32位和64位系统上是不一样的，所以size_t方面系统之间的移植，而size_typei配套类型，是为了string类和vector类对象的长度的一个存储</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br></pre></td></tr></table></figure>

<p>C++元组tuple：就是可以存储任意类型的数组，通常用来存储多个不同类型的数据</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tuple&lt;string,vector&lt;double&gt;,int,list&lt;int&gt;&gt; someVal("tuple",&#123;2.14,3.15&#125;,100,&#123;1,2,3&#125;);</span><br><span class="line">tuple&lt;<span class="keyword">int</span>,<span class="keyword">int</span>,<span class="keyword">double</span>&gt; some&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">3.15</span>&#125;;<span class="comment">//这样也行，注意与上面的括号</span></span><br></pre></td></tr></table></figure>

<p>可以使用make_tuple函数直接生成tuple对象，使用auto进行声明（这和之前说的动态类型是一回事）</p>
</li>
</ol>
<hr>
<h1 id="02-11："><a href="#02-11：" class="headerlink" title="02/11："></a>02/11：</h1><h3 id="第35天，前几天，继续看了一下内存管理方面的知识，然后就是量子融合门对应的代码部分，所以在网上找资料很重要，可以给你提供优化的方向，而且因为收集的资料会因为题目的不同而不同，所以这个全靠习惯了"><a href="#第35天，前几天，继续看了一下内存管理方面的知识，然后就是量子融合门对应的代码部分，所以在网上找资料很重要，可以给你提供优化的方向，而且因为收集的资料会因为题目的不同而不同，所以这个全靠习惯了" class="headerlink" title="第35天，前几天，继续看了一下内存管理方面的知识，然后就是量子融合门对应的代码部分，所以在网上找资料很重要，可以给你提供优化的方向，而且因为收集的资料会因为题目的不同而不同，所以这个全靠习惯了"></a>第35天，前几天，继续看了一下内存管理方面的知识，然后就是量子融合门对应的代码部分，所以在网上找资料很重要，可以给你提供优化的方向，而且因为收集的资料会因为题目的不同而不同，所以这个全靠习惯了</h3><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><h3 id="关键字：分页、动态类型、assert-、MPI、张量、使用intel编译器"><a href="#关键字：分页、动态类型、assert-、MPI、张量、使用intel编译器" class="headerlink" title="关键字：分页、动态类型、assert()、MPI、张量、使用intel编译器"></a>关键字：分页、动态类型、assert()、MPI、张量、使用intel编译器</h3><ol>
<li>分页：<ol>
<li>对象：对<strong>虚拟存储器</strong>使用分页技术</li>
<li>地址：由程序产生的地址是虚地址（就是在程序调用中的地址，比如 mv reg,1000,），整个程序的虚拟地址构成虚地址空间，虚地址送到内存管理单元（MMU）映射为物理地址，这个物理地址应该是内存的地址</li>
<li>过程：先将完整的程序放到磁盘上，这样程序片段在需要时可以调入（不同的虚拟地址可能映射到相同的物理地址中），一次是将磁盘中的一页映射到内存中 </li>
<li>缺失：当要使用的页不在内存中时，操作系统将最少使用的页框中的内容写入到磁盘中，然后将需要的页取到刚释放的页框中（并不是简单的覆盖，要先将内存中内容写入磁盘）<ol>
<li>页框就是在内存中的分页</li>
</ol>
</li>
</ol>
</li>
<li>动态类型：<ol>
<li>在运行时进行类型检查，“静态类型”：在编译阶段检查类型，实现“动态类型”，依靠的是类型推导，通过上下文来判断类型，这个在C++中也有实现，1. 重定义auto关键字，2. 实现decltype</li>
<li>auto关键字在声明变量时，必须进行初始化，因为是通过初始化的内容来进行类型判断的</li>
</ol>
</li>
<li>assert()：<ol>
<li>C++的一个函数</li>
<li>作用是如果条件返回错误，则终止程序执行</li>
</ol>
</li>
<li>MPI：采用简单暴力的多进程来实现并行。即将同样的程序拷贝给所有的处理器去执行。 没有冗余容错机制，也没有MapRecude。 唯一提供的就是进程间的通信</li>
<li>张量：<ol>
<li>按照任意维排列的一堆数字的推广</li>
<li>标量、向量以及矩阵分别对应零维、一维以及二维的张量</li>
</ol>
</li>
<li>使用intel编译器：<ol>
<li><a href="https://blog.csdn.net/gengshenghong/article/details/7034748" target="_blank" rel="noopener">使用Intel编译器系列合集</a></li>
</ol>
</li>
</ol>
<h2 id="明天：-1"><a href="#明天：-1" class="headerlink" title="明天："></a>明天：</h2><ol>
<li>继续看intel的代码，其中会涉及许多C++的特性，所以要多谷歌</li>
<li>FPGA部分修改代码</li>
<li>看操作系统相关的知识</li>
<li>上面这些都是我目前可以做的，也是需要做的，看情况来做吧，因为只做一件事情可能会陷入到牛角尖中</li>
</ol>
<hr>
<h1 id="02-08："><a href="#02-08：" class="headerlink" title="02/08："></a>02/08：</h1><h3 id="第32天：一无所获"><a href="#第32天：一无所获" class="headerlink" title="第32天：一无所获"></a>第32天：一无所获</h3><hr>
<h1 id="02-07"><a href="#02-07" class="headerlink" title="02/07:"></a>02/07:</h1><h3 id="第31天：没有什么收获，没有做什么"><a href="#第31天：没有什么收获，没有做什么" class="headerlink" title="第31天：没有什么收获，没有做什么"></a>第31天：没有什么收获，没有做什么</h3><h3 id="关键字：Linux复制多个文件"><a href="#关键字：Linux复制多个文件" class="headerlink" title="关键字：Linux复制多个文件"></a>关键字：Linux复制多个文件</h3><ol>
<li><p>Linux复制多个文件：</p>
<ol>
<li><pre><code class="bash">cp /home/usr/dir/{file1,file2,file3,file4} /home/usr/destination/ <span class="comment">#文件名不能有空格</span>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">2. &#96;&#96;&#96;bash</span><br><span class="line">   cp &#x2F;home&#x2F;usr&#x2F;dir&#x2F;file&#123;1..4&#125; .&#x2F;	#有共同前缀</span><br></pre></td></tr></table></figure>


</code></pre>
</li>
</ol>
</li>
</ol>
<hr>
<h1 id="02-06："><a href="#02-06：" class="headerlink" title="02/06："></a>02/06：</h1><h3 id="第30天：前几天有时什么也没做，做了也没有多大的收获，找资料很重要，强哥找了很多的资料，所以走在了我们的前面"><a href="#第30天：前几天有时什么也没做，做了也没有多大的收获，找资料很重要，强哥找了很多的资料，所以走在了我们的前面" class="headerlink" title="第30天：前几天有时什么也没做，做了也没有多大的收获，找资料很重要，强哥找了很多的资料，所以走在了我们的前面"></a>第30天：前几天有时什么也没做，做了也没有多大的收获，找资料很重要，强哥找了很多的资料，所以走在了我们的前面</h3><h3 id="关键字：传统数据包的传输方式、零拷贝技术、dpdk、量子算法的作用、仿真量子电路的作用"><a href="#关键字：传统数据包的传输方式、零拷贝技术、dpdk、量子算法的作用、仿真量子电路的作用" class="headerlink" title="关键字：传统数据包的传输方式、零拷贝技术、dpdk、量子算法的作用、仿真量子电路的作用"></a>关键字：传统数据包的传输方式、零拷贝技术、dpdk、量子算法的作用、仿真量子电路的作用</h3><ol>
<li><p>传统数据包的传输方式</p>
<p><img src="https://raw.githubusercontent.com/Pipepw/FigureBed/master/blog_files/img/PicGo-Github-PicBed/image-20200207093716856.png" alt="image-20200207093716856"></p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/66595734" target="_blank" rel="noopener">零拷贝技术</a>：</p>
<p>就是没有CPU的参与，没有内核空间与用户空间之间的拷贝</p>
</li>
<li><p>dpdk：</p>
<ol>
<li>网上dpdk的资料都是对dpdk的分析和使用，也就是说dpdk并不是一个用来优化代码的开发工具</li>
<li>DPDK：在x86结构中，处理数据包的传统方式是CPU中断，也就是网卡就收到数据包之后产生一个CPU中断信息，使CPU停下手头的工作来处理数据包，然后由CPU拷贝数据并交给协议栈。这对CPU的效率有很大的影响<br>而DPDK则采用轮询方式处理数据包，DPDK重载网卡驱动，使网卡接受数据包之后不产生中断信息，而是将数据包通过零拷贝技术存入内存，然后应用程序通过DPDK提供的接口直接从内存读取数据包</li>
</ol>
</li>
<li><p>量子算法的作用：</p>
<p>可以接受表示许多不同可能输入的相干叠加的输入状态，然后将它们转换为相应的输出叠加， 这样就可以同时对叠加的每个元素产生影响，也就是并行的操作，这样可以提高计算效率</p>
</li>
<li><p>仿真量子电路的作用：</p>
<p>仿真量子电路是为了开发量子算法并验证量子设备，评估正确性</p>
</li>
</ol>
<hr>
<h1 id="01-31："><a href="#01-31：" class="headerlink" title="01/31："></a>01/31：</h1><h3 id="第23天：前面十几天什么也没做，今天主要做的还是和巨页有关，就是按照华科的方法修改代码，但是要修改的地方比较多，后来看了强哥发的博客，受益良多，然后就开始看操作系统有关的知识了"><a href="#第23天：前面十几天什么也没做，今天主要做的还是和巨页有关，就是按照华科的方法修改代码，但是要修改的地方比较多，后来看了强哥发的博客，受益良多，然后就开始看操作系统有关的知识了" class="headerlink" title="第23天：前面十几天什么也没做，今天主要做的还是和巨页有关，就是按照华科的方法修改代码，但是要修改的地方比较多，后来看了强哥发的博客，受益良多，然后就开始看操作系统有关的知识了"></a>第23天：前面十几天什么也没做，今天主要做的还是和巨页有关，就是按照华科的方法修改代码，但是要修改的地方比较多，后来看了强哥发的博客，受益良多，然后就开始看操作系统有关的知识了</h3><h3 id="关键字：批量重命名、C-的malloc、extern-“C-、vim替换、分页和交换、连接、重定位、保护、PSW、基址和界限寄存器、位图和自由链表"><a href="#关键字：批量重命名、C-的malloc、extern-“C-、vim替换、分页和交换、连接、重定位、保护、PSW、基址和界限寄存器、位图和自由链表" class="headerlink" title="关键字：批量重命名、C++的malloc、extern “C"、vim替换、分页和交换、连接、重定位、保护、PSW、基址和界限寄存器、位图和自由链表"></a>关键字：批量重命名、C++的malloc、extern “C"、vim替换、分页和交换、连接、重定位、保护、PSW、基址和界限寄存器、位图和自由链表</h3><ol>
<li><p>批量重命名：（需要安装rename）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rename <span class="string">'s/.c/.cpp/'</span> *  <span class="comment">#不知道具体含义，只知道是将c后缀换为cpp后缀</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>C++的malloc：</p>
<p>如果你写成：p = malloc (sizeof(int)); 则程序无法通过编译，报错：“不能将 void* 赋值给 int * 类型变量”。所以必须通过 (int *) 来将强制转换</p>
</li>
<li><p>extern “C"：</p>
<ol>
<li>在extern “C” 之间需要纯C的语法，否则会报错</li>
<li>出现 “template with C linkage”的错误</li>
</ol>
</li>
<li><p>vim替换：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">:s/vivian/sky/ <span class="comment">#替换当前行第一个 vivian 为 sky</span></span><br><span class="line"></span><br><span class="line">:s/vivian/sky/g <span class="comment">#替换当前行所有 vivian 为 sky</span></span><br><span class="line"></span><br><span class="line">:n,<span class="variable">$s</span>/vivian/sky/ <span class="comment">#替换第 n 行开始到最后一行中每一行的第一个 vivian 为 sky</span></span><br><span class="line"></span><br><span class="line">:n,<span class="variable">$s</span>/vivian/sky/g <span class="comment">#替换第 n 行开始到最后一行中每一行所有 vivian 为 sky,n 为数字，若 n 为 .，表示从当前行开始到最后一行	</span></span><br><span class="line"></span><br><span class="line">:%s/vivian/sky/(等同于 :g/vivian/s//sky/) <span class="comment">#替换每一行的第一个 vivian 为 sky</span></span><br><span class="line"></span><br><span class="line">:%s/vivian/sky/g(等同于 :g/vivian/s//sky/g) <span class="comment">#替换每一行中所有 vivian 为 sky,可以使用 # 作为分隔符，此时中间出现的 / 不会作为分隔符</span></span><br><span class="line"></span><br><span class="line">:s<span class="comment">#vivian/#sky/# #替换当前行第一个 vivian/ 为 sky/</span></span><br><span class="line"></span><br><span class="line">:%s+/oradata/apras/+/user01/apras1+ <span class="comment">#(使用+ 来 替换 / )： /oradata/apras/替换成/user01/apras1/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>分页和交换：</p>
<ol>
<li>分页：将主存划分为多块区域，刚开始是固定的，后来是可变的</li>
<li>交换：把各个进程完整地调入主存，运行一段时间，再放回到磁盘上，这时的分区是可变分区，需要多少分配多少，这样做会导致主存被分为多个块，并且形成空洞</li>
<li>通常会为进程分配大一点的空间，用来之后需要的增长，当分配的空间不够时，如果临近有空洞，则将空洞分配给进程空间，如果没有空洞，则需要将其交换到足够的空间中，如果磁盘已经占满了，则需要等待或者被杀死，而在进程被换出时，只需要将使用的空间换出就好了（交换：主存和磁盘之间的交换，从磁盘加载到主存，从主存换出到磁盘）<br>一个进程，将数据的栈段放在进程所占内存的顶端并向下增长，多分配的内存就在这个栈段的下面，如果用完了，则需要移动到足够大的空洞中或者交换出内存，或者被杀死</li>
<li>分区是为多进程而生的，交换是为解决主存不够而引入的</li>
</ol>
</li>
<li><p>链接： 把主程序、用户编写的例程、库例程结合到同一个地址空间中</p>
</li>
<li><p>重定位：一个程序中的指令指定的地址是在程序中的绝对地址，如果在程序加载到主存中使用这个绝对地址的话，是会出错的，因为在主存中的绝对地址应该是程序加载的地址+绝对地址，解决方法就是在加载程序的时候就对指令进行修改，这个就是重定位</p>
</li>
<li><p>保护：将主存划分为2K字节的块，并且为每一个块分配4位的保护码，PSW中包含一个4位的密钥，若保护码与密钥不匹配，则由硬件引起一个陷入（这个就是异常处理中的自陷吧），只有操作系统能够修改保护码和密钥，所以可以阻止用户进程干涉其他进程或操作系统本身</p>
</li>
<li><p>PSW：记录处理器的运行状态，如条件码、模式、控制位，其实就是状态寄存器，有无进位、有无溢出等都包含在其中</p>
</li>
<li><p>基址和界限寄存器：基址寄存器中存放的是进程的分区的起始地址，界限寄存器中存放的是分区的长度，这样做就可以同时满足重定位和保护了</p>
</li>
<li><p>位图和自由链表：</p>
<ol>
<li><p>跟踪内存使用情况的两种方法：位图、自由链表</p>
</li>
<li><p>位图：将内存分为分配单元，分配单元有大有小，未被占用则用0表示，被占用则用1表示，这样就能方便的表示内存的使用情况了，但是由于为进程分配空间是需要在位图中查找连续的0串，而这是一个缓慢的操作（因为串可能跨越字边界，字符串匹配问题？）</p>
</li>
<li><p>自由链表：</p>
<p><img src="https://raw.githubusercontent.com/Pipepw/FigureBed/master/blog_files/img/PicGo-Github-PicBed/image-20200201100642716.png" alt="image-20200201100642716"></p>
</li>
</ol>
</li>
</ol>
<hr>
<h1 id="01-19："><a href="#01-19：" class="headerlink" title="01/19："></a>01/19：</h1><h3 id="第十一天：上午把openMP的基础知识看完了，下午看了看《并行算法设计与性能优化》收获了不少，这个时候主要认为优化可能还是要从QuEST目录下的代码下手"><a href="#第十一天：上午把openMP的基础知识看完了，下午看了看《并行算法设计与性能优化》收获了不少，这个时候主要认为优化可能还是要从QuEST目录下的代码下手" class="headerlink" title="第十一天：上午把openMP的基础知识看完了，下午看了看《并行算法设计与性能优化》收获了不少，这个时候主要认为优化可能还是要从QuEST目录下的代码下手"></a>第十一天：上午把openMP的基础知识看完了，下午看了看《并行算法设计与性能优化》收获了不少，这个时候主要认为优化可能还是要从QuEST目录下的代码下手</h3><h3 id="关键字：空间局部性、时间局部性、越过缓存、使用流加载或流存储指令、硬件预取、Linux查看Cache的信息、Cache-Line-伪共享处理方案、动态内存分配、缓存命中与数据依赖性、解决TLB不命中导致的性能问题、从程序运行时看有哪些需要优化的地方、数据依赖、reduction子句、相同函数调用的问题"><a href="#关键字：空间局部性、时间局部性、越过缓存、使用流加载或流存储指令、硬件预取、Linux查看Cache的信息、Cache-Line-伪共享处理方案、动态内存分配、缓存命中与数据依赖性、解决TLB不命中导致的性能问题、从程序运行时看有哪些需要优化的地方、数据依赖、reduction子句、相同函数调用的问题" class="headerlink" title="关键字：空间局部性、时间局部性、越过缓存、使用流加载或流存储指令、硬件预取、Linux查看Cache的信息、Cache Line 伪共享处理方案、动态内存分配、缓存命中与数据依赖性、解决TLB不命中导致的性能问题、从程序运行时看有哪些需要优化的地方、数据依赖、reduction子句、相同函数调用的问题"></a>关键字：空间局部性、时间局部性、越过缓存、使用流加载或流存储指令、硬件预取、Linux查看Cache的信息、Cache Line 伪共享处理方案、动态内存分配、缓存命中与数据依赖性、解决TLB不命中导致的性能问题、从程序运行时看有哪些需要优化的地方、数据依赖、reduction子句、相同函数调用的问题</h3><ol>
<li><p>空间局部性：附近的数据有可能被访问</p>
</li>
<li><p>时间局部性：有可能再次被访问</p>
</li>
<li><p>越过缓存：具有空间局部性而不具有时间局部性，这时通过硬件为读写分配几条长度和缓存线长度相同的缓冲区即可。使用流加载或流存储的概念，如在SSE/AVX中的_mm_stream_load、__mm_stream_store等</p>
</li>
<li><p>使用流加载或流存储指令要求数据访问的步长为1，如下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">	b[i] += a[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上，由于处理器已经进行了许多优化，所以有可能并不能提高性能</p>
</li>
<li><p>处理器每次都是加载的一条缓存线，有可能可以通过启用BIOS的选项启动硬件预取，当然，是否能提高性能和代码有关、</p>
</li>
<li><p><img src="https://raw.githubusercontent.com/Pipepw/FigureBed/master/blog_files/img/PicGo-Github-PicBed/image-20200119161922005.png" alt="image-20200119161922005"></p>
</li>
<li><p>Linux 查看Cache的信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /sys/devices/system/cpu/cpu0/cache/index0/</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/Pipepw/FigureBed/master/blog_files/img/PicGo-Github-PicBed/image-20200119163018574.png" alt="image-20200119163018574"></p>
</li>
<li><h3 id="Cache-Line伪共享处理方案"><a href="#Cache-Line伪共享处理方案" class="headerlink" title="Cache Line伪共享处理方案"></a>Cache Line伪共享处理方案</h3><p>处理伪共享的两种方式：</p>
<ol>
<li>增大数组元素的间隔使得不同线程存取的元素位于不同的cache line上。典型的空间换时间。（Linux cache机制与之相关）</li>
<li>在每个线程中创建全局数组各个元素的本地拷贝，然后结束后再写回全局数组。</li>
</ol>
</li>
<li><p>动态内存分配：</p>
<ol>
<li>非常慢，原因有两个：</li>
<li>堆分配器必须处理任何大小的分配请求（不知道为啥会有影响，难道是因为在处理小数据的时候，按照大数据进行处理， 从而减低了效率）</li>
<li>malloc()/free()需要从用户模式切换到内核模式，处理请求然后再换回来，这种上下文切换非常耗时</li>
</ol>
</li>
<li><p>除了要考虑缓存命中，还应该考虑数据依赖性的问题</p>
<p><img src="https://raw.githubusercontent.com/Pipepw/FigureBed/master/blog_files/img/PicGo-Github-PicBed/image-20200119173202248.png" alt="image-20200119173202248"></p>
<p><img src="https://raw.githubusercontent.com/Pipepw/FigureBed/master/blog_files/img/PicGo-Github-PicBed/image-20200119173206767.png" alt="image-20200119173206767"></p>
<p>后者虽然有可能提高缓存命中率，但是增加了数据的依赖性，所以性能反而更低了</p>
</li>
<li><p>解决TLB不命中导致的性能问题：</p>
<ol>
<li>增加页的大小</li>
<li>对于重复使用且局部性好的多位数据，临时分配数据空间来存储</li>
<li>避免满不命中，对数据进行分块</li>
</ol>
</li>
<li><p>从程序运行时看有哪些需要优化的地方：</p>
<ol>
<li>如果处理器的利用率一直都是100%，则限制因素是处理器，需要减少计算<ol>
<li>优化计算：<ol>
<li>减少计算数量</li>
<li>表达式移除</li>
<li>分支优化</li>
<li>优化算法</li>
</ol>
</li>
</ol>
</li>
<li>如果处理器利用率率不高但很平稳，则需要测试程序的内存带宽，比较程序的带宽和内存能提供的带宽（内存的有效带宽 ，可以用stream工具），注意减少存储器的访问</li>
<li>如果处理器的利用率忽高忽低，则要查找是什么导致处理器长时间的空闲，常见因素是由其他进程占用处理器</li>
<li>还需要考虑网络速度、利用率以及网络负载均衡<ol>
<li>如果网络的利用率很高，但是数据传输还是很慢<ol>
<li>查看是否网线或网卡的带宽不够</li>
<li>是否网络拓扑或路由设置不好，导致数据传输需要经过节点过多</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>数据依赖：</p>
<ol>
<li>读后写：也会产生数据依赖，这种称为“反依赖”，不能并行操作，但是实际上并没有依赖，因为写比读要慢的多</li>
</ol>
</li>
<li><p>reduction子句：</p>
<ol>
<li>reducion是在副本的基础上进行操作，最后将每个线程的结果值按照规定的运算符进行运算<br>这是一个归约操作<br>只可以使用+,*,-,&,|,^,&&,||八种运算符</li>
</ol>
</li>
<li><p>相同函数调用的问题：</p>
<ol>
<li>从CMakeLists.txt中进行了区分，如果是分布式就使用distributed，如果是单机，就使用local，根据CMakeLists.txt中的DISTRIBUTED进行区分，这个选项是在QuEST目录下的CMakeLists.txt进行赋值</li>
</ol>
</li>
</ol>
<hr>
<h1 id="01-18："><a href="#01-18：" class="headerlink" title="01/18："></a>01/18：</h1><h3 id="第十天：上午继续看了看巨页的知识，然后发现服务器不支持AVX512所以暂时不管向量化了，下午看了看openmp的知识，然后开始对进行函数内联，但是好像没有啥效果"><a href="#第十天：上午继续看了看巨页的知识，然后发现服务器不支持AVX512所以暂时不管向量化了，下午看了看openmp的知识，然后开始对进行函数内联，但是好像没有啥效果" class="headerlink" title="第十天：上午继续看了看巨页的知识，然后发现服务器不支持AVX512所以暂时不管向量化了，下午看了看openmp的知识，然后开始对进行函数内联，但是好像没有啥效果"></a>第十天：上午继续看了看巨页的知识，然后发现服务器不支持AVX512所以暂时不管向量化了，下午看了看openmp的知识，然后开始对进行函数内联，但是好像没有啥效果</h3><ol>
<li><p>我的目标是使用巨页，如何使用巨页，在哪使用巨页</p>
<ol>
<li>如何使用巨页：<ol>
<li>通过使用mmap指定映射的内核内存空间的大小，从而达到指定巨页的目的</li>
<li>我看到的都是将一个变量放到这个文件的内核空间里面，所以使用的时候就是将变量映射到内核空间里面</li>
</ol>
</li>
<li>这样做的好处是什么<ol>
<li>将用户空间和内核空间映射起来，这样就可以直接进行访问，而不需要复制了</li>
</ol>
</li>
<li>我使用巨页的目的是什么<ol>
<li>扩大内存页，从而达到减少页缺失的目的</li>
<li>如果使用mmap，如何达到这个目的呢？<ol>
<li>猜想：<ol>
<li>将整个内存页设置为一个文件，对这个指针进行读写操作</li>
<li>但是这样的话，一个内存页中应该有许多不同的内容，这样应该如何进行处理呢？</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>华科：<br>将使用mmap将内核内存映射为mm_data，这是mmap_allocator结构体中的数据成员，这个成员演化为了一个vector容器，这个容器又成了另一个结构体KBM中的元素，KBM构体又在了KBMAux结构体中嵌套了，</li>
</ol>
</li>
<li><p>openmp：</p>
<ol>
<li><p>可以从缓存的角度进行优化，执行顺序不同，缓存的考虑不同，如</p>
<p><img src="https://raw.githubusercontent.com/Pipepw/FigureBed/master/blog_files/img/PicGo-Github-PicBed/image-20200118151933428.png" alt="image-20200118151933428"></p>
<p><img src="https://raw.githubusercontent.com/Pipepw/FigureBed/master/blog_files/img/PicGo-Github-PicBed/image-20200118151953483.png" alt="image-20200118151953483"></p>
</li>
</ol>
</li>
<li><p>可以从缓存的角度进行优化，执行顺序不同，缓存的考虑不同，<br>这个是因为最内层是对k递增，而数组的k是在第三维，所以跨度比较大，有可能不在同一个缓存区域内，导致较长的延迟</p>
</li>
<li><p>函数内联：</p>
<ol>
<li>在 .c 文件中对函数使用 inline 关键字，就可以将函数内联</li>
<li>不能使用 static inline，不然会出现各种各样的错误</li>
<li>如果要使用 static inline，则需要其他文件没有调用这个函数才行</li>
</ol>
</li>
</ol>
<hr>
<h1 id="01-17"><a href="#01-17" class="headerlink" title="01/17:"></a>01/17:</h1><h3 id="第九天：主要是看巨页方面的知识，我负责的方向是向量化"><a href="#第九天：主要是看巨页方面的知识，我负责的方向是向量化" class="headerlink" title="第九天：主要是看巨页方面的知识，我负责的方向是向量化"></a>第九天：主要是看巨页方面的知识，我负责的方向是向量化</h3><ol>
<li><p>他们是调用了mmap这个内存映射函数，所以本身就可以将用户空间的内存映射到内核空间中，而巨页的内存正好出在内核空间中</p>
<ol>
<li>大页文件系统<ol>
<li>是一个伪文件系统，通过mmap将文件映射到内存中，对内存操作（具体是怎么操作的呢？）</li>
<li>通过mmap获得内存地址，从而对内存进行读写（和正常的操作一样）</li>
</ol>
</li>
</ol>
</li>
<li><p>mmap是用来将内存映射到文件，也就是将文件或者其他对象映射到进程的 空间，这样就实现了文件磁盘地址和进程虚拟地址空间中的一段虚拟地址的一一映射关系。这样就可以通过指针读写这一段内存了（这个指针就是文件），这个指针的实际情况是vm_area_struct这个结构体的指针，这个结构体中包含起始地址和终止地址以及其他信息，而mmap函数的作用就是创建一个新的vm_area_struct结构，并将其与文件的物理磁盘地址相连</p>
<p><img src="E:%5Chexo%5Csource%5C_posts%5C%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93.assets%5C20200517085407.png" alt=""></p>
</li>
<li><p>回调函数：通过函数指针调用的函数，（函数名也是一个地址）</p>
</li>
</ol>
<hr>
<h1 id="01-15-01-16："><a href="#01-15-01-16：" class="headerlink" title="01/15-01/16："></a>01/15-01/16：</h1><h3 id="第七和第八天，这两天在北京集训，学到了不少东西"><a href="#第七和第八天，这两天在北京集训，学到了不少东西" class="headerlink" title="第七和第八天，这两天在北京集训，学到了不少东西"></a>第七和第八天，这两天在北京集训，学到了不少东西</h3><img src="https://raw.githubusercontent.com/Pipepw/FigureBed/master/blog_files/img/PicGo-Github-PicBed/image-20200117214049384.png" alt="image-20200117214049384" style="zoom: 50%;" />

<p><img src="https://raw.githubusercontent.com/Pipepw/FigureBed/master/blog_files/img/PicGo-Github-PicBed/image-20200117214213004.png" alt="image-20200117214213004"></p>
<hr>
<h1 id="01-14："><a href="#01-14：" class="headerlink" title="01/14："></a>01/14：</h1><h3 id="第六天：去北京的第一天，什么都没做，甚至还打了一天的游戏"><a href="#第六天：去北京的第一天，什么都没做，甚至还打了一天的游戏" class="headerlink" title="第六天：去北京的第一天，什么都没做，甚至还打了一天的游戏"></a>第六天：去北京的第一天，什么都没做，甚至还打了一天的游戏</h3><hr>
<h1 id="01-13："><a href="#01-13：" class="headerlink" title="01/13："></a>01/13：</h1><h3 id="第五天，第二天就要去北京了，所以看了一天的CUDA"><a href="#第五天，第二天就要去北京了，所以看了一天的CUDA" class="headerlink" title="第五天，第二天就要去北京了，所以看了一天的CUDA"></a>第五天，第二天就要去北京了，所以看了一天的CUDA</h3><ol>
<li><p>使用CUDA：</p>
<ol>
<li>安装CUDA</li>
<li>将编译器的位置替换为nvcc所在的位置</li>
</ol>
</li>
<li><p>查看系统发行版</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname -m &amp;&amp; cat /etc/*release</span><br></pre></td></tr></table></figure>



<hr>
<h1 id="01-12："><a href="#01-12：" class="headerlink" title="01/12："></a>01/12：</h1><h3 id="第四天：今天依然在看cmake，是为了能够修改里面的参数"><a href="#第四天：今天依然在看cmake，是为了能够修改里面的参数" class="headerlink" title="第四天：今天依然在看cmake，是为了能够修改里面的参数"></a>第四天：今天依然在看cmake，是为了能够修改里面的参数</h3><h3 id="关键字：make的参数、cmake中变量的作用域、接下来怎么做、"><a href="#关键字：make的参数、cmake中变量的作用域、接下来怎么做、" class="headerlink" title="关键字：make的参数、cmake中变量的作用域、接下来怎么做、"></a>关键字：make的参数、cmake中变量的作用域、接下来怎么做、</h3><h3 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h3><ol>
<li><p>make的参数：</p>
<ol>
<li><p>VERBOSE：</p>
<p>在make时，使用make VERBOSE=1 可以查看详细的编译信息</p>
<p><img src="https://raw.githubusercontent.com/Pipepw/FigureBed/master/blog_files/img/PicGo-Github-PicBed/image-20200112093334695.png" alt="image-20200112093334695"></p>
</li>
<li><p>-e参数可以强制使系统中的环境变量覆盖到Makefile中的环境变量（默认是相反的）</p>
<p>也可以使用<strong>VAR=VALUE</strong>来指定覆盖某一个</p>
</li>
</ol>
</li>
<li><p>cmake中变量的作用域</p>
<p>cmake中，根目录的变量可以放到子目录中，但子目录中的变量在根目录中不能使用</p>
<p>如果想要使用，则需要添加PARENT_SCOPE参数，如</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_C_FLAGS <span class="string">"-std=c99"</span> PARENT_SCOPE)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="接下来怎么做："><a href="#接下来怎么做：" class="headerlink" title="接下来怎么做："></a>接下来怎么做：</h3><ol>
<li><p>在cmake中可以看到有使用CUDA和GPU的选项，所以在Quest的程序中对CUDA和GPU的支持是已经存在了的，只需要在服务器回来之后将参数修改一下就行</p>
<p>现在可以做的是在虚拟机上试一下修改哪些参数有效，只要能够跑起来就行</p>
</li>
<li><p>继续看代码，看有没有优化的方法（这个方向，我有点不想去尝试）</p>
</li>
<li><p>从那个集训日程可以看出，主要的方向有Intel加速、IB&RDMA加速、CUDA加速，加下来可以看一下相关的内容，至少要先了解一下</p>
<p>那个认证培训原价90美元，所以这次要想办法将它的作用发挥到最大，需要提前了解一下CUDA相关的，至少是培训相关的</p>
</li>
</ol>
<hr>
<h1 id="01-11："><a href="#01-11：" class="headerlink" title="01/11："></a>01/11：</h1><h3 id="第三天：今天主要是看cmake，以便于读懂程序执行的过程"><a href="#第三天：今天主要是看cmake，以便于读懂程序执行的过程" class="headerlink" title="第三天：今天主要是看cmake，以便于读懂程序执行的过程"></a>第三天：今天主要是看cmake，以便于读懂程序执行的过程</h3><h3 id="关键字：复制一个目录中的所有文件到另一个目录、端口、Makefile中-PHONY的作用、maxstartups、收集资料的方式"><a href="#关键字：复制一个目录中的所有文件到另一个目录、端口、Makefile中-PHONY的作用、maxstartups、收集资料的方式" class="headerlink" title="关键字：复制一个目录中的所有文件到另一个目录、端口、Makefile中.PHONY的作用、maxstartups、收集资料的方式"></a>关键字：复制一个目录中的所有文件到另一个目录、端口、Makefile中.PHONY的作用、maxstartups、收集资料的方式</h3><h3 id="总结：-2"><a href="#总结：-2" class="headerlink" title="总结："></a>总结：</h3><ol>
<li><p>目录中的所有文件到另一个目录</p>
<ol>
<li><p>如果dir2目录不存在，则可以直接使用</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp -r dir1 dir2</span><br></pre></td></tr></table></figure>

<p>如果dir2目录已存在，则需要使用</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp -r dir1/. dir2</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>收集资料的方式：</p>
<p>在不同的网站上搜索相关的资料，例如：知乎，维基百科等</p>
</li>
<li><p>端口</p>
<ol>
<li><p>端口是什么<br>不同的应用开启了不同的端口，这样在通信的时候就知道是那个应用的信息了，比如同时开启了FTP和WWW服务时，每一种服务有特定的端口，这时会有一些空的端口留下来 使用<br>端口有两种，分别为TCP端口和UDP端口<br>计算机通信有两种方式，一种是发送信息之后可以确认信息是否送达，采用TCP协议<br>另一种是发送之后就不管了，这种采用UDP协议<br>（这两种在网络中都是处在传输层中）<br>端口号的范围：1~65535(2^16，int型数据的范围）</p>
</li>
<li><p>端口分为3大类（按端口号）：</p>
<ol>
<li><p>公认端口：0-1023，与一些服务是绑定的，如21是FTP服务，25是SMTP服务（简单邮件传输协议），80是HTTP服务，135是RPC服务（远程过程调用）；这种绑定并不都是固定的，有的可以自己指定，如WWW服务的端口</p>
</li>
<li><p>动态端口：1024-65535，需要时再打开</p>
</li>
<li><p>常见的端口号及其用途：</p>
<p>0用于分析操作系统（因为有些系统中0是无效端口）</p>
<p>1，tcpmux</p>
<p>22，就是给ssh的</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>Makefile中.PHONY的作用</p>
<ol>
<li><p>防止在Makefile中定义的只执行命令的目标与文件名字发生冲突</p>
<p>比如一个文件的名称是clean，那么就无法执行make clean操作</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/Pipepw/FigureBed/master/blog_files/img/PicGo-Github-PicBed/image-20200111203149432.png" alt="image-20200111203149432"></p>
<p><img src="https://raw.githubusercontent.com/Pipepw/FigureBed/master/blog_files/img/PicGo-Github-PicBed/image-20200111203156508.png" alt="image-20200111203156508"></p>
<p><img src="https://raw.githubusercontent.com/Pipepw/FigureBed/master/blog_files/img/PicGo-Github-PicBed/image-20200111203214750.png" alt="image-20200111203214750"></p>
<p><img src="https://raw.githubusercontent.com/Pipepw/FigureBed/master/blog_files/img/PicGo-Github-PicBed/image-20200111203218824.png" alt="image-20200111203218824"></p>
<ol start="2">
<li>提高执行Makefile时的效率</li>
</ol>
</li>
<li><p>若Makefile是由cmake生成的，则修改参数等应该在CMakeLists.txt中进行修改，</p>
</li>
<li><p>maxstartups：</p>
<p>ssh中的maxstartups是用来设置最大连接数的，默认的 Maxstartups 10:30:60，意思是从第10个连接开始以30%的概率（递增）拒绝新连接，直到连接数达到60为止</p>
</li>
</ol>
<hr>
<h1 id="01-10："><a href="#01-10：" class="headerlink" title="01/10："></a>01/10：</h1><h3 id="第二天"><a href="#第二天" class="headerlink" title="第二天"></a>第二天</h3><h3 id="总结：-3"><a href="#总结：-3" class="headerlink" title="总结："></a>总结：</h3><ol>
<li>是摸鱼的一天，甚至没有摸鱼，滑雪去了</li>
</ol>
<hr>
<h1 id="01-09："><a href="#01-09：" class="headerlink" title="01/09："></a>01/09：</h1><h3 id="正式开始超算的第一天"><a href="#正式开始超算的第一天" class="headerlink" title="正式开始超算的第一天"></a>正式开始超算的第一天</h3><ol>
<li>今天应该做的是熟悉一下题目，看一下程序是什么样的</li>
</ol>
<h3 id="收获："><a href="#收获：" class="headerlink" title="收获："></a>收获：</h3><ol>
<li><p>学会了如何内网穿透</p>
<ol>
<li><p>内网穿透是用一个公网的服务器作为跳板的<br>ssh反向穿透是让服务器主动发起请求连接客户端，然后在客户端打开一个端口，之后发往客户端的数据包会转发到服务端<br>所以ssh反向穿透是让内网服务器主动连接外网服务器，那个12347就是对应的端口，如使用</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -NR 22022:localhost:22 clientUser@clientMachine</span><br></pre></td></tr></table></figure>

<p>则是将发往客户端22022的数据包转发到服务器的22端口上，这个时候如果客户端有公网ip，那么就可以利用客户端为跳板，远程登录到内网服务器上，通过使用</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -p22022 serverUser@clientMachine</span><br></pre></td></tr></table></figure>

<p>而在408的服务器中，则是将端口12347映射过去了</p>
</li>
</ol>
</li>
</ol>
<pre><code>##### 使用autossh来进行持久化连接

安装autossh之后，执行下面的命令

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">autossh -M 0 -f -o <span class="string">"ServerAliveInterval=30"</span> -o <span class="string">"ServerAliveCountMax=3"</span> -o <span class="string">"ExitOnForwardFailure=yes"</span> -NR 22022:localhost:22 jump@jumpServer</span><br></pre></td></tr></table></figure>

出了 -M 0 和 -f 是autossh的参数，其他的参数都是传递给ssh的，-M 0表示不另开端口检测ssh

ps：

1. 以前的autossh使用-M来开启另一个端口发送心跳数据包，而新版的ssh内建了心跳功能
2. 心跳包：客户端和服务器间定时通知对方自己状态的一个命令字，就是用来确定自己还在线的</code></pre><ol start="2">
<li><p>大致知道接下来应该做什么：</p>
<ol>
<li>跟着刘佳伦配置好相应的环境</li>
<li>学习CUDA相关的知识</li>
</ol>
</li>
</ol>
<hr>
<h1 id="01-03："><a href="#01-03：" class="headerlink" title="01/03："></a>01/03：</h1><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><hr>
<h1 id="01-02"><a href="#01-02" class="headerlink" title="01/02:"></a>01/02:</h1><h3 id="总结：-4"><a href="#总结：-4" class="headerlink" title="总结："></a>总结：</h3><ol>
<li>维持不一致的能力：<ol>
<li>就是让不一致的东西一直存在</li>
<li>有两个方面<ol>
<li>与自己思维的不一致：<ol>
<li>思考一下有哪些地方不一致</li>
<li>为什么会不一致</li>
<li>有哪些是需要我进行改正的</li>
</ol>
</li>
<li>外在的不一致：<ol>
<li>认同他们的存在，存在就是合理</li>
<li>就如同没有完全分明的对和错一样</li>
</ol>
</li>
</ol>
</li>
<li>我要怎么做：<ol>
<li>求同存异</li>
<li>不断进步</li>
<li>多向反方向进行思考<ol>
<li>比如觉得这件事很不错，或者这个东西很不错，就想一下有没有什么是不是那么好的</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>掌握控制点的能力：<ol>
<li>控制点有两个端点：<ol>
<li>内在控制点：<ol>
<li>感觉是自己在控制</li>
<li>当事情的发展和我预期的一样时就会有这样的感觉</li>
</ol>
</li>
<li>外在控制点：<ol>
<li>感觉自己不能够控制</li>
<li>当突发了一些事情时，比如能力比我强大的人</li>
</ol>
</li>
</ol>
</li>
<li>我要做什么：<ol>
<li>把握好这个度，既不能过于偏向于自己的一端，也不能过于偏向于外界的一端<ol>
<li>过于向内，则容易失去对外界的认识</li>
<li>过于向外，则容易失去对自己的把握</li>
</ol>
</li>
<li>对于遇到的问题，有控制点的距离分为三个部分进行思考<ol>
<li>控制点在内时，想一下自己可以做什么来增加收获</li>
<li>控制点在中间时，想一下自己可以通过谁去干预</li>
<li>控制点在外面时，想一下自己可以做什么来减低风险</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>抵抗时间扭曲的能力：<ol>
<li>人们总是倾向于高估当下，低估未来</li>
<li>我要做什么：<ol>
<li>避免主观的干扰，用量化的思维去思考问题，将问题进行具体化</li>
<li>每天做一些近期没有意义的事情，主要是用来增强抵抗时间扭曲的能力</li>
</ol>
</li>
</ol>
</li>
<li>思维显示化的能力：<ol>
<li>就是将自己的想法具体化，而不只是在潜意识当中</li>
<li>这个和我之前将自己的思考过程记录下来是一个道理</li>
<li>我还可以做什么：<ol>
<li>总结一套适合自己的思考核对表或流程，遇到问题时，按照这个流程去思考<ol>
<li>这个和我之前写cpu时的debug的总结是一样的，不过我局限于debug了，相对来说，debug是很简单的一个总结，因为已经足够具体化，就是一个方法论而已，而在现实生活中往往有着复杂的多的问题，情况也特别多，所以要将遇到的问题都记录下来，不然想总结也找不到依据</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>演绎思考的能力：<ol>
<li>多想一下为什么会这样</li>
</ol>
</li>
</ol>
<h3 id="明天：-2"><a href="#明天：-2" class="headerlink" title="明天："></a>明天：</h3><ol>
<li>上午：看两章马原，将思维导图画出来</li>
<li>下午：将物理都抄完</li>
<li>晚上：概率论和线代</li>
</ol>
<hr>
<h1 id="01-01："><a href="#01-01：" class="headerlink" title="01/01："></a>01/01：</h1><h3 id="总结：-5"><a href="#总结：-5" class="headerlink" title="总结："></a>总结：</h3><ol>
<li>新的一年开始了，以游戏的方式开启，上一年也是以游戏的方式结束的，这样可不太行嗷</li>
<li>还是需要每天规划好才行，不然的话，就把时间用到了思考做什么上，一思考就想着打游戏了</li>
<li>同时还需要记录每天花费的时间，一方面是更好的知道自己做了什么，另一方面是为了激励自己不断的学习</li>
</ol>
<h3 id="明天：-3"><a href="#明天：-3" class="headerlink" title="明天："></a>明天：</h3><ol>
<li>上午背马原<ol>
<li>至少背7页的内容</li>
<li>也就是将第一章背完概论</li>
<li>并且背一页的第二章</li>
</ol>
</li>
<li>下午背物理<ol>
<li>先看一下概念</li>
<li>将题抄下来</li>
<li>背题</li>
</ol>
</li>
<li>晚上做概率论和线代<ol>
<li>每个至少做一章</li>
</ol>
</li>
</ol>
<hr>
<h1 id="12-23："><a href="#12-23：" class="headerlink" title="12/23："></a>12/23：</h1><h3 id="明天：-4"><a href="#明天：-4" class="headerlink" title="明天："></a>明天：</h3><ol>
<li>上午看100页java，以及制定复习计划</li>
</ol>
<hr>
<h1 id="12-22："><a href="#12-22：" class="headerlink" title="12/22："></a>12/22：</h1><h3 id="关键字：HTTP基础概念、RDMA、如何学习、单指令多数据、多指令多数据"><a href="#关键字：HTTP基础概念、RDMA、如何学习、单指令多数据、多指令多数据" class="headerlink" title="关键字：HTTP基础概念、RDMA、如何学习、单指令多数据、多指令多数据"></a>关键字：HTTP基础概念、RDMA、如何学习、单指令多数据、多指令多数据</h3><h3 id="总结：-6"><a href="#总结：-6" class="headerlink" title="总结："></a>总结：</h3><ol>
<li><p>TCP/IP协议族</p>
<ol>
<li>HTTP的关键内容，其实HTTP是TCP/IP协议族的一个子集</li>
<li>其中还有ICMP、UDP等协议<ol>
<li>ICMP协议：<ol>
<li>用来处理连接错误的情况的</li>
<li>由每一个IP模块组成</li>
<li>与IP同属网络层</li>
</ol>
</li>
<li>UDP协议：<ol>
<li>可靠性较差但是性能好</li>
<li>与TCP同属传输层</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>RDMA：</p>
<ol>
<li>概括来讲，rdma就是避开了从用户空间到kernel空间的复制以及一系列数据操作，直接从这个内存传输到目标内存中</li>
<li>减少了对带宽的占用、释放cpu使用、避免复制以及上下文切换带来的开销</li>
</ol>
</li>
<li><p>如何学习：</p>
<ol>
<li>提出原因：学习效率低下，总是会忘掉之前学的内容</li>
<li>解决方法：<ol>
<li>学习过程中不断进行思考，通过动手将自己的想法记录下来</li>
<li>不断进行总结，没有总结就是收获</li>
<li>如果没有时间记录，那么就将关键字记下</li>
</ol>
</li>
</ol>
</li>
<li><p>单指令多数据：</p>
<ol>
<li><p>一条指令同时对多个数据进行操作</p>
</li>
<li><pre><code>a = b + c；
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   3. 一个加法操作，同时对 b，c 三个数据进行操作</span><br><span class="line"></span><br><span class="line">5. 多指令多数据：</span><br><span class="line"></span><br><span class="line">   1. 多条指令同时对多个数据进行操作</span><br><span class="line"></span><br><span class="line">   2.</span><br></pre></td></tr></table></figure>
a = (b+c) + (b-c) + (b*c);</code></pre></li>
<li><p>如果加法，减法以及乘法都有着单独的处理单元，如果就可以同时进行加减以及乘法操作</p>
</li>
<li><p>在我的指令集中，虽然除法有着单独的处理单元，但是每个周期都会与ex进行通信，并且会阻塞流水线，所以不能算是多指令操作</p>
</li>
</ol>
</li>
</ol>
<h3 id="明天"><a href="#明天" class="headerlink" title="明天"></a>明天</h3><ol>
<li>上午看一下java、线代和概论如何复习</li>
<li>下午看一下物理实验如何复习，以及制定复习计划（具体到每一科什么时候开始复习，应该怎么进行复习）</li>
<li>晚上看一下pynq如何进行调用ip核的，看一下rdma的内容（至少把知乎上的看完）</li>
<li>下午看一下物理实验如何复习，以及制定复习计划（</li>
</ol>
<hr>
<h1 id="12-18"><a href="#12-18" class="headerlink" title="12/18"></a>12/18</h1><h3 id="关键字：启用或禁用-Intel-睿频加速技术"><a href="#关键字：启用或禁用-Intel-睿频加速技术" class="headerlink" title="关键字：启用或禁用 Intel 睿频加速技术"></a>关键字：启用或禁用 Intel 睿频加速技术</h3><ol>
<li>从 System Utilities 屏幕中，选择 System Configuration（系统配置） > BIOS/Platform Configuration (RBSU)（BIOS/平台配置） > Performance Options（性能选项） > Intel (R) Turbo Boost Technology（Intel (R) 睿频加速技术），然后按 Enter。      </li>
<li>选择一个设置，然后按 Enter。<ol>
<li>Enabled（已启用）- 启用支持超线程技术的处理器上的逻辑处理器内核。           </li>
<li>Disabled（已禁用）- 降低功耗以及系统在某些工作负载下的最高可用性能。           </li>
</ol>
</li>
<li>按 F10。  </li>
</ol>
<hr>
<h1 id="12-17："><a href="#12-17：" class="headerlink" title="12/17："></a>12/17：</h1><h3 id="关键字：总结、无法链接到-so-文件、异常处理相关"><a href="#关键字：总结、无法链接到-so-文件、异常处理相关" class="headerlink" title="关键字：总结、无法链接到 .so 文件、异常处理相关"></a>关键字：总结、无法链接到 .so 文件、异常处理相关</h3><h3 id="总结：-7"><a href="#总结：-7" class="headerlink" title="总结："></a>总结：</h3><ol>
<li><p>没有总结就是没有收获，没有收获就是白给</p>
</li>
<li><p>当出现没有办法链接到一个 .so 文件时，很可能是因为没有连接到文件中，需要进行修改</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/ld.so.conf</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 在里面直接添加so文件所在的目录就好了</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>异常处理相关</p>
<ol>
<li><p>在id阶段，获取的是指令相关的异常</p>
<ol>
<li>是否为有效指令</li>
<li>是否为eret指令</li>
<li>是否为syscall指令</li>
</ol>
<p>在ex阶段，获取的是运算相关的异常</p>
<ol>
<li>是否发生溢出异常</li>
<li>是否为自陷异常，</li>
<li>这是一个单独的操作，其他的操作都不用管</li>
<li>因为是有符号数，所以</li>
</ol>
<p>在mem阶段，根据cp0中寄存器的值以及传过来的excepttype进行相应的处理，cp0中的寄存器是Status寄存器以及Cause寄存器</p>
<p>处理异常的方式：</p>
<ol>
<li>在cp0中进行处理</li>
<li>需要的数据：<ol>
<li>excepttype的值</li>
<li>发生异常的指令</li>
<li>还有是否为延迟槽指令</li>
</ol>
</li>
<li>进行的操作：<ol>
<li>跳转到异常处理例程入口（通过设置pc的值）</li>
<li>清空流水线中寄存器中的值</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="明天：-5"><a href="#明天：-5" class="headerlink" title="明天："></a>明天：</h3><ol>
<li>明天上午：<ol>
<li>第一节课没啥了，口语考试</li>
<li>第二节课回宿舍学习ASC相关的</li>
</ol>
</li>
<li>明天下午：<ol>
<li>上课的时候复习、那就复习离散和线代了吧</li>
</ol>
</li>
<li>明天晚上继续完成cpu的内容</li>
</ol>
<hr>
<h1 id="12-13："><a href="#12-13：" class="headerlink" title="12/13："></a>12/13：</h1><h3 id="总结：-8"><a href="#总结：-8" class="headerlink" title="总结："></a>总结：</h3><h3 id="明天：-6"><a href="#明天：-6" class="headerlink" title="明天："></a>明天：</h3><ol>
<li>做题、做题、做题</li>
</ol>
<hr>
<h1 id="12-12："><a href="#12-12：" class="headerlink" title="12/12："></a>12/12：</h1><h3 id="关键字：马拉车算法、zsh使用通配符、安装oh-my-zsh、从windows访问wsl文件、find排除访问目录或文件"><a href="#关键字：马拉车算法、zsh使用通配符、安装oh-my-zsh、从windows访问wsl文件、find排除访问目录或文件" class="headerlink" title="关键字：马拉车算法、zsh使用通配符、安装oh-my-zsh、从windows访问wsl文件、find排除访问目录或文件"></a>关键字：马拉车算法、zsh使用通配符、安装oh-my-zsh、从windows访问wsl文件、find排除访问目录或文件</h3><ol>
<li><p>马拉车算法：</p>
<ol>
<li><p>线性时间内找出最长回文子串的方法</p>
</li>
<li><p>目的：消除中心扩张法的重叠部分</p>
</li>
<li><p>方式：使用一个数组b和两个辅助mx、id</p>
</li>
<li><p>原理：</p>
<ol>
<li>动态规划：利用之前找出来的回文子串</li>
<li>id两侧是对称的，而找的一定是右边的，所以直接等于左边的就好了</li>
</ol>
</li>
<li><p>需要注意的是：</p>
<ol>
<li><p>有可能左边的范围很大</p>
<p><img src="https://raw.githubusercontent.com/Pipepw/FigureBed/master/blog_files/img/PicGo-Github-PicBed/image-20191213000458183.png" alt="image-20191213000458183"></p>
</li>
<li><p>有可能左边的范围很小</p>
<p><img src="https://raw.githubusercontent.com/Pipepw/FigureBed/master/blog_files/img/PicGo-Github-PicBed/image-20191213000627934.png" alt="image-20191213000627934"></p>
</li>
<li><p>找到两者中的最小值，然后进行扩展</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>zsh使用通配符：需要用引号括起来</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo find / -name '*fuck*'</span><br></pre></td></tr></table></figure>
</li>
<li><p>find排除访问目录或文件</p>
<ol>
<li><p>排除访问目录：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo find / -path '/mnt*' -a -prune -o -name '*hydra*'</span><br></pre></td></tr></table></figure>

<p>其中 -path '/mnt*' -a -prune 就表示排除mnt及其子目录</p>
</li>
<li><p>排除文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo find ./cache ! -name '*.html' -type f</span><br></pre></td></tr></table></figure>

<p>其中 ! -name '*.html' 就表示排除后缀为.html的文件</p>
</li>
</ol>
</li>
<li><p>安装oh-my-zsh</p>
<ol>
<li><p>自动安装</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh</span><br></pre></td></tr></table></figure>
</li>
<li><p>手动安装</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh</span><br><span class="line">cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>从windows访问wsl文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd \wsl$\Ubuntu-18.04</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="明天：-7"><a href="#明天：-7" class="headerlink" title="明天："></a>明天：</h3><hr>
<h1 id="12-10："><a href="#12-10：" class="headerlink" title="12/10："></a>12/10：</h1><h3 id="明天：-8"><a href="#明天：-8" class="headerlink" title="明天："></a>明天：</h3><ol>
<li>上午：<ol>
<li>第一节课学习线代</li>
<li>第二节课回宿舍写实验报告</li>
</ol>
</li>
<li>下午：<ol>
<li>继续完善我的cpu（其实应该好好规划一下接下来应该怎么做了）</li>
</ol>
</li>
<li>晚上：<ol>
<li>做两道算法题吧</li>
</ol>
</li>
</ol>
<hr>
<h1 id="12-09："><a href="#12-09：" class="headerlink" title="12/09："></a>12/09：</h1><h3 id="关键字：协处理器访问指令、如何编译mips汇编、"><a href="#关键字：协处理器访问指令、如何编译mips汇编、" class="headerlink" title="关键字：协处理器访问指令、如何编译mips汇编、"></a>关键字：协处理器访问指令、如何编译mips汇编、</h3><hr>
<h1 id="12-08："><a href="#12-08：" class="headerlink" title="12/08："></a>12/08：</h1><h3 id="关键字：ll以及sc指令、接下来对cpu的学习、协处理器"><a href="#关键字：ll以及sc指令、接下来对cpu的学习、协处理器" class="headerlink" title="关键字：ll以及sc指令、接下来对cpu的学习、协处理器"></a>关键字：ll以及sc指令、接下来对cpu的学习、协处理器</h3><h3 id="总结：-9"><a href="#总结：-9" class="headerlink" title="总结："></a>总结：</h3><ol>
<li>ll 以及 sc 指令：<ol>
<li>其实就是lw以及sw的增强版，多了对LLbit_reg的操作</li>
<li>只有这两条指令涉及到对LLbit_reg的操作</li>
<li>当发生异常或者现成切换时会将LLbit_reg设置为0，这时sc指令无效</li>
</ol>
</li>
<li>接下来对cpu的学习：<ol>
<li>书中没有涉及缓存、MMU、TLB等</li>
<li>接下来根据需求进行完善，如果我自己的操作系统需要这些功能的话，则实现它</li>
</ol>
</li>
<li>协处理器：<ol>
<li>通过设置寄存器的值进行控制</li>
<li>类似于HILO寄存器</li>
<li>这里实现的主要与异常处理有关，没有实现缓存等相关的内容</li>
<li>通过mtc0以及mfc0进行设置和读取寄存器的值</li>
</ol>
</li>
</ol>
<h3 id="明天：-9"><a href="#明天：-9" class="headerlink" title="明天："></a>明天：</h3><ol>
<li>明天上午<ol>
<li>在宿舍时，试一下能不能用wsl2，看知乎上的那篇文章</li>
<li>第二节课实现mtc0以及mfc0</li>
</ol>
</li>
<li>明天下午<ol>
<li>学习离散</li>
<li>学习算法</li>
</ol>
</li>
<li>明天晚上<ol>
<li>看一篇ASC的文章</li>
<li>整理一下有哪些需要实践的内容</li>
</ol>
</li>
</ol>
<hr>
<h1 id="12-07："><a href="#12-07：" class="headerlink" title="12/07："></a>12/07：</h1><h3 id="明天：-10"><a href="#明天：-10" class="headerlink" title="明天："></a>明天：</h3><ol>
<li>？？？？</li>
</ol>
<hr>
<h1 id="12-06："><a href="#12-06：" class="headerlink" title="12/06："></a>12/06：</h1><h3 id="明天：-11"><a href="#明天：-11" class="headerlink" title="明天："></a>明天：</h3><ol>
<li>上午实现 ll 以及 sc 指令</li>
<li>下午写总结，然后去博雅</li>
<li>晚上继续实现cpu的功能</li>
</ol>
<hr>
<h1 id="12-05："><a href="#12-05：" class="headerlink" title="12/05："></a>12/05：</h1><h3 id="关键字：巨页（大内存页）、ASC、VM提示不兼容、dd命令、搜索东西、CSM、下板"><a href="#关键字：巨页（大内存页）、ASC、VM提示不兼容、dd命令、搜索东西、CSM、下板" class="headerlink" title="关键字：巨页（大内存页）、ASC、VM提示不兼容、dd命令、搜索东西、CSM、下板"></a>关键字：巨页（大内存页）、ASC、VM提示不兼容、dd命令、搜索东西、CSM、下板</h3><h3 id="总结：-10"><a href="#总结：-10" class="headerlink" title="总结："></a>总结：</h3><ol>
<li><p>巨页：</p>
<ol>
<li>就是用于设置内存页大小的，因为默认的是4k的大小，这样很容易发生页缺失的情况，从而导致性能降低，所以通过增大页的大小，从而提高性能</li>
<li>具体的操作在笔记中有所保存，可以试一下对性能的提升有多大的帮助</li>
</ol>
</li>
<li><p>ASC（接下来怎么做）：</p>
<ol>
<li>看往年的题</li>
<li>使用里面提到的技术</li>
</ol>
</li>
<li><p>出现VM提示不兼容的情况：在powershell中运行并重启电脑</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bcdedit &#x2F;set hypervisorlaunchtype off</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果想要打开hyper-V：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bcdedit &#x2F;set hypervisorlaunchtype auto</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="5">
<li><p>dd命令：</p>
<ol>
<li>用于转换和复制文件</li>
<li>通常是用来创建镜像的</li>
</ol>
</li>
<li><p>搜索东西：</p>
<ol>
<li>与一些会涉及到的内容一起搜索，也许会有意外收获</li>
<li>比如使用 “控制功耗 ASC” 进行搜索，会出现不少相关的文章，而在只搜索ASC时则不会出现</li>
</ol>
</li>
<li><p>CSM：</p>
<ol>
<li>BIOS中的一个启动选项</li>
<li>一些旧的显卡可能无法使用UEFI进行启动，这时需要在BIOS中将CSM选项打开，并将所有的optional bootrom 从 UEFI 改成 Legacy</li>
</ol>
</li>
<li><p>下板：</p>
<ol>
<li>综合不能识别initial等</li>
<li>对于文件的读取，在cpu中是替换为使用 Block Memory Generator 这个IP核进行存储指令，因为本身就是指令存储器</li>
<li>其他地方应该没用到这样的东西了</li>
</ol>
</li>
</ol>
<h3 id="明天：-12"><a href="#明天：-12" class="headerlink" title="明天："></a>明天：</h3><ol>
<li>明天上午：<ol>
<li>第一节课将cpu那个改一下，如果时序没有问题的话，那么可以直接出结果了</li>
<li>第二节课把线代看一下，将之前落下的内容补起来</li>
</ol>
</li>
<li>明天中午问一下离散的问题，其实不是有问题，而是没有橡皮擦</li>
<li>明天下午：<ol>
<li>第一节课学习离散和算法</li>
<li>第二节课学习ASC相关的，看一个人的博客</li>
</ol>
</li>
<li>明天晚上继续完成cpu相关的内容：<ol>
<li>下板</li>
<li>完成剩下的指令</li>
</ol>
</li>
</ol>
<hr>
<h1 id="12-03："><a href="#12-03：" class="headerlink" title="12/03："></a>12/03：</h1><h3 id="明天：-13"><a href="#明天：-13" class="headerlink" title="明天："></a>明天：</h3><ol>
<li>第一节课复习数字逻辑</li>
<li>第二节课看一下有没有办法</li>
</ol>
<hr>
<h1 id="12-01："><a href="#12-01：" class="headerlink" title="12/01："></a>12/01：</h1><h3 id="明天：-14"><a href="#明天：-14" class="headerlink" title="明天："></a>明天：</h3><ol>
<li>上午在宿舍写离散和心理那个</li>
<li>物理课上复习数字逻辑</li>
<li>下午学习离散和数字逻辑</li>
</ol>
<hr>
<h1 id="11-27："><a href="#11-27：" class="headerlink" title="11/27："></a>11/27：</h1><h3 id="关键字：旁路数据、数据冲突、如何阻塞、伪指令、表格的markdown语法、MIPS与数组、下一个周期使用的数据"><a href="#关键字：旁路数据、数据冲突、如何阻塞、伪指令、表格的markdown语法、MIPS与数组、下一个周期使用的数据" class="headerlink" title="关键字：旁路数据、数据冲突、如何阻塞、伪指令、表格的markdown语法、MIPS与数组、下一个周期使用的数据"></a>关键字：旁路数据、数据冲突、如何阻塞、伪指令、表格的markdown语法、MIPS与数组、下一个周期使用的数据</h3><h3 id="总结：-11"><a href="#总结：-11" class="headerlink" title="总结："></a>总结：</h3><ol>
<li>旁路数据：<ol>
<li>旁路数据只能解决在ex阶段使用数据的情况<ol>
<li>因为数据是旁路到id中的，而冲突也是在id阶段进行判断的，所以不能在id阶段进行使用</li>
<li><strong>如果要用旁路</strong>解决load指令与其他指令的数据冲突，应该将数据旁路到ex阶段</li>
</ol>
</li>
</ol>
</li>
<li>数据冲突：<ol>
<li>不用考虑在data_ram中的数据冲突，比如上一条指令是sw而下一条指令是lw</li>
<li>因为对data_ram的操作都是在一个时钟周期内完成的最多就是写需要一个周期，在下一条指令来的时候，也已经写完成了</li>
<li>为什么不会触发之前创建的旁路：<ol>
<li>因为当运行到lw运行到mem阶段的时候，beq指令已经运行到</li>
</ol>
</li>
</ol>
</li>
</ol>
<hr>
<h1 id="11-25："><a href="#11-25：" class="headerlink" title="11/25："></a>11/25：</h1><h3 id="关键字：流水线周期、解决问题、赋值错误、加载存储指令"><a href="#关键字：流水线周期、解决问题、赋值错误、加载存储指令" class="headerlink" title="关键字：流水线周期、解决问题、赋值错误、加载存储指令"></a>关键字：流水线周期、解决问题、赋值错误、加载存储指令</h3><h3 id="总结：-12"><a href="#总结：-12" class="headerlink" title="总结："></a>总结：</h3><ol>
<li>流水线周期：<ol>
<li>判断指令之间时钟周期的距离时，通过指令之间的距离就行了，比如相邻的指令就是相差一个时钟周期，间隔一个的指令就是相差两个时钟周期</li>
<li>每一个阶段只消耗一个时钟周期，这个时钟周期实际上是由中间部件决定的，比如ex_mem这种，因为id、ex等都是组合逻辑，只有中间部件是时序电路，所以id、ex等都是一个时钟周期</li>
<li>所以判断时间间隔最好的方法就是看指令之间的距离，而不是看时序图一个一个的对应查找</li>
</ol>
</li>
<li>赋值错误：<ol>
<li>由上可知，赋值操作也是在一个时钟周期内完成了，并且在一个时钟周期内完成多次赋值操作</li>
<li>那么有没有可能发生赋值错误的情况呢，比如这个值之前是xx这种不确定值，需要向另一个模块获取具体的值</li>
<li>答案是：不会，因为在一个时钟周期内可能会完成多次赋值，只要敏感列表发生变化，那么就会执行always块里面的内容，所以在最后一次执行的时候，就已经是一个确定的值了</li>
</ol>
</li>
<li>解决问题：<ol>
<li>定位每个指令是什么</li>
<li>通过aluop进行定位</li>
<li>应该先查看控制信号是否出错，从上往下的进行查找</li>
</ol>
</li>
<li>加载存储指令：<ol>
<li>都是对一个字的内容进行的操作</li>
<li>通过对齐后的地址确定处理哪一个字的内容</li>
<li>通过sel控制处理这个字上哪一个字节上的内容<ol>
<li>sel是由指令类型以及地址共同决定的</li>
<li>sel只在 LR型指令中有作用，其他的指令是通过addr_i[1:0]来决定的（其实这两个差不多的）</li>
<li>注意将1的值与要处理的数据对应起来</li>
</ol>
</li>
<li>不论是读还是写，都涉及对存储模块的处理，所以要将ce的值设置为1</li>
</ol>
</li>
</ol>
<h3 id="明天：-15"><a href="#明天：-15" class="headerlink" title="明天："></a>明天：</h3><ol>
<li>明天上午<ol>
<li>第一节课完成线代的作业</li>
<li>解决data_ram的数据冲突，设计程序（将典型的c语言程序转换为机器语言）</li>
</ol>
</li>
<li>明天下午看情况完成，带上数字逻辑、线代以及电脑</li>
<li>晚上<ol>
<li>上课的时候完成离散剩下的内容</li>
<li>下课之后设计端口</li>
</ol>
</li>
<li>空闲时间看一下要怎样设计ppt</li>
</ol>
<hr>
<h1 id="11-23："><a href="#11-23：" class="headerlink" title="11/23："></a>11/23：</h1><h3 id="关键字：怎么解决问题"><a href="#关键字：怎么解决问题" class="headerlink" title="关键字：怎么解决问题"></a>关键字：怎么解决问题</h3><h3 id="总结：-13"><a href="#总结：-13" class="headerlink" title="总结："></a>总结：</h3><ol>
<li>怎么解决问题：<ol>
<li>先写仿真</li>
<li>先查找问题的开始</li>
<li>然后一步步追根溯源/<em>/9+3</em></li>
<li>+-</li>
<li>.3/9</li>
<li>/不用全部理解代码，每次回溯遇到不懂的问他就行</li>
</ol>
</li>
<li>今天好像啥也没干，就只是把基础的部分完成了，其他的啥也没干</li>
</ol>
<h3 id="明天：-16"><a href="#明天：-16" class="headerlink" title="明天："></a>明天：</h3><ol>
<li>明天上午进行测试吧<ol>
<li>完成剩下的内容</li>
<li>接下来就是想办法把这个搞到板子上了</li>
</ol>
</li>
<li>下午把这个搞到板子上，具体的工作留到明天进行</li>
</ol>
<hr>
<h1 id="11-22："><a href="#11-22：" class="headerlink" title="11/22："></a>11/22：</h1><h3 id="关键字：增加功能、加载存储指令"><a href="#关键字：增加功能、加载存储指令" class="headerlink" title="关键字：增加功能、加载存储指令"></a>关键字：增加功能、加载存储指令</h3><h3 id="总结：-14"><a href="#总结：-14" class="headerlink" title="总结："></a>总结：</h3><ol>
<li>增加功能：正确的操作应该是：<ol>
<li>先把数据通路创建，在这个过程中理解一下指令执行的过程</li>
<li>然后再一个阶段一个阶段的进行完善、</li>
</ol>
</li>
<li>加载存储指令：<ol>
<li>其实没ex什么事，对地址的计算最后在mem中也有，不如都放到mem中</li>
<li>不过如果是存储指令的话，需要将要存储的数据找出来<ol start="3">
<li>地址对齐</li>
<li>分为两类，简单类以及l r 类<ol>
<li>简单类，直接根据地址进行获取就行了</li>
<li>l r 类需要算出偏移的大小，这一步是放到mem阶段进行的，所以ex阶段只需要将地址传过去就行了</li>
</ol>
</li>
<li>需要用到base（也就是reg1的值）</li>
</ol>
</li>
<li>在mem阶段<ol>
<li>加66666666666666666666666666666666666666666666666668载指令：<ol>
<li>10*0简单类：<ol>
<li>根据指令的类型，选择获取数据的范围</li>
<li>起始地址就是传递进来的地址</li>
</ol>
</li>
<li>l r 类：<ol>
<li>根据指令类型，计算获取数据的范围</li>
<li>起始地址：<ol>
<li>如果是 l，则将传入地址作为起始地址</li>
<li>如果是 r，则将对齐地址作为起始地址</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>存储指令：<ol>
<li>与加载指令类似</li>
</ol>
</li>
<li>根据使能信号写入或读取ram，ram与regfile类似</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="11-21："><a href="#11-21：" class="headerlink" title="11/21："></a>11/21：</h1><h3 id="关键字：为什么取字要求低位为0、大端存储、最高以及最低有效位、增加功能、遇到的问题"><a href="#关键字：为什么取字要求低位为0、大端存储、最高以及最低有效位、增加功能、遇到的问题" class="headerlink" title="关键字：为什么取字要求低位为0、大端存储、最高以及最低有效位、增加功能、遇到的问题"></a>关键字：为什么取字要求低位为0、大端存储、最高以及最低有效位、增加功能、遇到的问题</h3><h3 id="总结：-15"><a href="#总结：-15" class="headerlink" title="总结："></a>总结：</h3><ol>
<li>为什么取字要求低位为0：<ol>
<li>最根本的原因：要满足对齐</li>
<li>当取一个字，也就是四个字节时，所以满足对齐的话，则必须能够被4整除，所以最低位为00，因为4是0100</li>
<li>取半个字的话，则必须能够被2整除，所以最低位为0，因为2是0010</li>
</ol>
</li>
<li>大端存储：<ol>
<li>大地址对应低位数据，比如地址为1 2 3 4 ，数据为 a b c d ，则d应该存放在第4位上，这样看好像也还是挺符合认知的</li>
</ol>
</li>
<li>最高有效位以及最低有效位：<ol>
<li><strong>最高有效位</strong>：所谓的最高指的是地址最高，也就是在指定地址后面的有效位，比如指定地址为5，则有效位为5 6 7 ，如果指定地址为6，则有效位为6 7</li>
<li><strong>最低有效位</strong>：由上可得，如果指定地址为5，那么有效位应该是4 5，如果指定地址为7，那么有效位为4 5 6 7，但是存储到目标寄存器时，还是要从低位开始存储</li>
</ol>
</li>
<li>增加功能：一个阶段一个阶段的进行修改</li>
<li>遇到的问题：当有多个上升沿时，有可能会出现 “ambiguous clock”的问题，这个问题出现的原因是if之后没有else，导致可能出现不确定的情况，所以记住将每一个if 最后要和else对应起来，case的default也是一样的</li>
</ol>
<h3 id="明天：-17"><a href="#明天：-17" class="headerlink" title="明天："></a>明天：</h3><ol>
<li>上午完成大部分基本的加载存储指令：<ol>
<li>第一节课完成id以及id_ex阶段</li>
<li>第二节课完成ex以及ex_mem阶段</li>
</ol>
</li>
<li>下午：<ol>
<li>完成剩下的mem阶段的内容</li>
<li>完成修改sopc的内容</li>
<li>测试基本的加载存储指令</li>
<li>理解剩下的内容</li>
</ol>
</li>
<li>晚上：<ol>
<li>完成剩下的内容</li>
</ol>
</li>
</ol>
<hr>
<h1 id="11-20："><a href="#11-20：" class="headerlink" title="11/20："></a>11/20：</h1><h3 id="关键字：寄存器地址、补码、编译器不作优化，分支延迟槽、跳转指令、编译过程中、数字逻辑的作用、总线与数据通路"><a href="#关键字：寄存器地址、补码、编译器不作优化，分支延迟槽、跳转指令、编译过程中、数字逻辑的作用、总线与数据通路" class="headerlink" title="关键字：寄存器地址、补码、编译器不作优化，分支延迟槽、跳转指令、编译过程中、数字逻辑的作用、总线与数据通路"></a>关键字：寄存器地址、补码、编译器不作优化，分支延迟槽、跳转指令、编译过程中、数字逻辑的作用、总线与数据通路</h3><h3 id="总结：-16"><a href="#总结：-16" class="headerlink" title="总结："></a>总结：</h3><ol>
<li><p>让编译器不作优化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.set noreorder      #添加伪操作，提示编译器不作优化</span><br><span class="line">.set nomacro</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译过程中：</p>
<ol>
<li>nop指令会被直接编译器忽视掉，因为在转换成的机器语言中没有输出</li>
<li>.org指令可能就是因为nop指令而无效的</li>
</ol>
</li>
<li><p>数字逻辑的作用：写出更有的方案，比如用更少的器件实现更多的功能</p>
</li>
<li><p>总线与数据通路：</p>
<ol>
<li>总线就是所有寄存器公用的通路</li>
<li>总线也是有很多位的，总线的位数由寄存器的位数决定</li>
<li>总线中应该只有一组数据吧</li>
</ol>
</li>
<li><p>补码：所有的数据在存入计算机的时候就已经是补码形式了</p>
</li>
<li><p>寄存器地址：</p>
<ol>
<li>寄存器地址就是他的标号，比如 $31 就是 5’b11111</li>
</ol>
</li>
<li><p>分支延迟槽：</p>
<ol>
<li><p>是什么：是转移指令后面的一条指令，位于延迟槽中的指令会先于分支指令提交</p>
<p>所谓先于分支指令提交是指：在分支跳转过去之前就已经执行了(因为是紧随在跳转指令后面执行的)</p>
</li>
<li><p>有什么用：</p>
<ol>
<li>用来传递子函数调用的参数</li>
<li>延迟槽指令结果作为跳转指令条件（？？？延迟槽中的指令只是相当于放在分支指令的前面，而在实际执行中应该还是在分支指令后面执行的，这样的话，怎么能作为跳转指令的条件呢？）做到后面应该可以明白</li>
</ol>
</li>
</ol>
</li>
<li><p>跳转指令：</p>
<ol>
<li>jr rs：用寄存器中的值作为跳转的地址</li>
<li>jalr rs 或 jalr rs,rd：感觉应该是用来调用函数的，因为要将返回地址保存下来，如果没有指令rd寄存器，则默认保存到寄存器$31中</li>
<li>j target：低28位为target左移4位后的结果，高4位为延迟槽指令的高4位，这个指令应该是用来页内跳转的，局部进行跳转</li>
<li>jal target：就是有返回地址的 j 指令</li>
</ol>
</li>
</ol>
<hr>
<h1 id="11-18："><a href="#11-18：" class="headerlink" title="11/18："></a>11/18：</h1><h3 id="关键字：多个阻塞、转移指令、不符合预期、贪心算法、分治算法、回溯算法"><a href="#关键字：多个阻塞、转移指令、不符合预期、贪心算法、分治算法、回溯算法" class="headerlink" title="关键字：多个阻塞、转移指令、不符合预期、贪心算法、分治算法、回溯算法"></a>关键字：多个阻塞、转移指令、不符合预期、贪心算法、分治算法、回溯算法</h3><h3 id="总结：-17"><a href="#总结：-17" class="headerlink" title="总结："></a>总结：</h3><ol>
<li>多个阻塞：当有多个阻塞时，将多个阻塞进行“或”操作，一个为真则全都为真</li>
<li>转移指令：通过修改pc寄存器的值进行转移操作</li>
<li>不符合预期：<ol>
<li>与计划中相比，主要是少了对ASC的学习，因为这个一直都没有开头，所以不了解导致一直都不能开始</li>
<li>所以应该找个时间强制学习一下</li>
</ol>
</li>
<li>贪心算法：局部最优从而结果最优</li>
<li>分治算法：典型就是归并算法，利用归并算法算出逆序度</li>
<li>回溯算法：递归的思想</li>
</ol>
<h3 id="明天：-18"><a href="#明天：-18" class="headerlink" title="明天："></a>明天：</h3><ol>
<li>上午：<ol>
<li>将表格填一下发给学姐，不知道明天下午能不能进去（小事）</li>
<li>学习转移指令，理解延迟槽，实现绝对转移指令</li>
</ol>
</li>
<li>下午：实现相对转移指令</li>
<li>晚上：算法题或者看一下</li>
</ol>
<hr>
<h1 id="11-17"><a href="#11-17" class="headerlink" title="11/17:"></a>11/17:</h1><h3 id="明天：-19"><a href="#明天：-19" class="headerlink" title="明天："></a>明天：</h3><ol>
<li>上午做实验，顺便把离散做了<ol>
<li>完成除法</li>
<li>理解转移</li>
</ol>
</li>
<li>中午下载软件</li>
<li>下午游泳和算法（因为之前学过，所以应该比较好理解）<ol>
<li>贪心算法</li>
<li>分治算法</li>
</ol>
</li>
<li>晚上看一下怎么做ASC<ol>
<li>主要是看有哪些原题</li>
<li>怎么做原题</li>
</ol>
</li>
</ol>
<hr>
<h1 id="11-16："><a href="#11-16：" class="headerlink" title="11/16："></a>11/16：</h1><h3 id="关键字：当需要初值时、除法操作、赋值"><a href="#关键字：当需要初值时、除法操作、赋值" class="headerlink" title="关键字：当需要初值时、除法操作、赋值"></a>关键字：当需要初值时、除法操作、赋值</h3><hr>
<h1 id="11-15："><a href="#11-15：" class="headerlink" title="11/15："></a>11/15：</h1><h3 id="关键字：查找错误、正确的改动、问题一直存在、解除阻塞、KMP算法、AC自动机、需要保存的数据"><a href="#关键字：查找错误、正确的改动、问题一直存在、解除阻塞、KMP算法、AC自动机、需要保存的数据" class="headerlink" title="关键字：查找错误、正确的改动、问题一直存在、解除阻塞、KMP算法、AC自动机、需要保存的数据"></a>关键字：查找错误、正确的改动、问题一直存在、解除阻塞、KMP算法、AC自动机、需要保存的数据</h3><h3 id="总结：-18"><a href="#总结：-18" class="headerlink" title="总结："></a>总结：</h3><ol>
<li><p>做出正确的改动之后，将其上传到github上，有助于之后进行debug</p>
</li>
<li><p>查找错误：</p>
<ol>
<li>根据其中的一条时序，判断每个位置上对应的指令是什么，记录下来（当然，也可以一条指令一条指令的进行调试）</li>
<li>最先找到第一条指令</li>
</ol>
</li>
<li><p>当问题一直存在时，将vivado关了再重新打开，也许会有帮助</p>
</li>
<li><p>解除阻塞：在多周期操作的最后一个阶段解除阻塞（别忘了），这个信号会马上发送到每个部件中</p>
</li>
<li><p>KMP算法：</p>
<ol>
<li><p>暴力算法：</p>
<ol>
<li>将两个字符串进行匹配，不符合则向后移动一位</li>
<li>这样做的时间复杂度是 n2，所以需要进行优化</li>
</ol>
</li>
<li><p>中心思想：</p>
<ol>
<li>利用动态规划，使发生不匹配之后尽量向后多移动几位，这个和BM算法比较类似</li>
<li>动态规划如何使用：后一个子串与前面查找的结果有关（准确的说是和前一个字符的结果有关）</li>
<li>这里的最长和次长都是相对于前一个字符来说的，其实就是那个数组的值</li>
</ol>
</li>
<li><p><strong>核心</strong>：next数组的建立</p>
<ol>
<li><p>next数组的作用：对模式串进行预处理，以便在失效时将模式串向后多移动几位</p>
</li>
<li><p>next数组中存放的是模式串中每个前缀的最长可匹配的前缀子串结尾字符的下标（这样在失效的时候就可以直接移动到那里去了）</p>
</li>
<li><p>最长可匹配前缀子串：前缀的后缀能匹配到的最长前缀子串</p>
</li>
<li><p>假设模式串为 ababc </p>
<ol>
<li><table>
<thead>
<tr>
<th align="center">前缀</th>
<th>后缀</th>
</tr>
</thead>
<tbody><tr>
<td align="center">a</td>
<td>0</td>
</tr>
<tr>
<td align="center">ab</td>
<td>0</td>
</tr>
<tr>
<td align="center">aba</td>
<td>a</td>
</tr>
<tr>
<td align="center">abab</td>
<td>ab</td>
</tr>
<tr>
<td align="center">ababc</td>
<td>0</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<ol start="4">
<li><p>过程：</p>
<ol>
<li><p>前一个匹配：</p>
<ol>
<li>当前字符相等：最长的子串加1</li>
<li>当前字符不相等：次长的子串加1<ol>
<li>这是一个递归的过程</li>
<li>比如有两个串：ababac 以及 ababab</li>
<li>过程：<ol>
<li>c != b，所以找ababa的最长可匹配前缀子串，也就是aba</li>
<li>aba的后一个 b = b，所以找到ababab的最长前缀子串为abab</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>前一个不匹配：</p>
<p>​    从头开始查找</p>
</li>
<li><p>问题转移：*</p>
<ol>
<li>如何查找次长可<strong>匹配</strong>前缀子串</li>
<li>限制在最长可匹配前缀子串中</li>
</ol>
</li>
</ol>
</li>
</ol>
<hr>
<h1 id="11-14："><a href="#11-14：" class="headerlink" title="11/14："></a>11/14：</h1><h3 id="关键字：记录、使用与输入、流水线暂停、多周期操作"><a href="#关键字：记录、使用与输入、流水线暂停、多周期操作" class="headerlink" title="关键字：记录、使用与输入、流水线暂停、多周期操作"></a>关键字：记录、使用与输入、流水线暂停、多周期操作</h3><h3 id="总结：-19"><a href="#总结：-19" class="headerlink" title="总结："></a>总结：</h3><ol>
<li>记录：<ol>
<li>有些记录是在纸上，有些记录是在电脑上，不用将两者同步，只需要最后综合到总结里就行了</li>
</ol>
</li>
<li>使用与输入：<ol>
<li>问题：实际使用的只有一位，但输入的数据确实6位，为什么不直接只输入一位</li>
<li>答：因为在顶层模块中的wire是不能赋值的，就像是一条真正的线一样，这和使用ip核进行组合时是一样的</li>
</ol>
</li>
<li>流水线暂停：<ol>
<li>为什么需要用到流水线暂停：因为有些操作需要两个或多个周期才能完成，所以流水线的其他部分需要等这些操作完成之后才能继续进行</li>
<li>流水线暂停是什么：在那个模块之前的模块状态保持不变，之后的模块继续执行</li>
<li>具体的实现：<ol>
<li>在多周期操作模块：<ol>
<li>一般发生在 id 以及 ex 阶段</li>
<li>这里以及后面的内容都假设是发生在ex阶段</li>
</ol>
</li>
<li>在 ex 阶段之前的模块需要保持不变，也就是对输出不进行赋值操作</li>
<li>在 ex 阶段前的一个模块，需要将输出变为空指令，因为如果不是空指令，那么就会发生重复执行一条指令的情况，这和我想达到的目的是相违背的</li>
<li>ex 之后的模块照常执行就好了，执行完本次周期之后，就都是空指令了</li>
</ol>
</li>
</ol>
</li>
<li>多周期操作：<ol>
<li>有哪些：<ol>
<li>乘累加、乘累减以及除法操作都是多周期操作</li>
<li>前两者都是两个周期，除法与位数有关，比如32位除法，那么就需要32个周期</li>
<li>这里以乘累加为例</li>
</ol>
</li>
<li>具体实现：<ol>
<li>乘累加指令分为两个操作，乘法以及加法，分别使用一个周期</li>
<li>需要用一个变量cnt来表示进行到了第几个周期，根据cnt的值来决定所执行的操作<ol>
<li>比如cnt为0时，执行乘法</li>
<li>cnt为1时，执行加法</li>
</ol>
</li>
<li>当后一个操作需要用到之前的数据时，需要先将数据存到ex_mem阶段，然后再作为输入返回到执行阶段中</li>
<li>不直接使用的原因：乘的结果不确定，有可能使用不确定值</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="明天：-20"><a href="#明天：-20" class="headerlink" title="明天："></a>明天：</h3><ol>
<li>上午第一节课学习算法：<ol>
<li>完成KMP算法的学习</li>
<li>完成AC自动机的学习</li>
</ol>
</li>
<li>第二节课做实验：<ol>
<li>完成乘累加、减操作</li>
<li>理解一下除法操作</li>
</ol>
</li>
<li>下午做实验：<ol>
<li>完成除法操作</li>
<li>理解一下转移指令</li>
</ol>
</li>
<li>晚上做两道算法题</li>
</ol>
<hr>
<h1 id="11-13："><a href="#11-13：" class="headerlink" title="11/13："></a>11/13：</h1><h3 id="关键字：计算机中的数据、正变负、赋值语句"><a href="#关键字：计算机中的数据、正变负、赋值语句" class="headerlink" title="关键字：计算机中的数据、正变负、赋值语句"></a>关键字：计算机中的数据、正变负、赋值语句</h3><h3 id="总结：-20"><a href="#总结：-20" class="headerlink" title="总结："></a>总结：</h3><ol>
<li><p>计算机中的数据：</p>
<ol>
<li>计算机中的数据保存下来就已经是补码的形式了，所以我在Verilog调用的过程中使用的也是补码的形式</li>
<li>所以正数的补码是其本身，负数的补码则是按位取反，末位加1，这个补码是对计算机而言的，如果用现实中的方法去计算是不能得到正确的值的，也就是说，一个数的补码（按照按位取反，末位加1的方法得到）得到的是一个数的负数形式，比如0011，补码为1101，如果按照我以前的方法（除去符号位取反），再次取“补码”，那么补码的“补码”就是1011，这个数在现实中的认知就是-3，正好是原数的相反数，同样，对一个负数取补码也是同样的道理，得到的是相反数，如果要得到真正的值，则需要对其取“补码”</li>
</ol>
</li>
<li><p>赋值语句：</p>
<ol>
<li>分为两种：<ol>
<li>assign：连续赋值语句</li>
<li>always：过程赋值语句</li>
</ol>
</li>
<li>两者的区别：<ol>
<li>assign是对wire类型进行的操作，当后面的数发生变化时，其结果会马上作用到前面的数上</li>
<li>而always是对reg类型进行的操作，只有当敏感列表发生变化时，里面的内容才会运行，所以很有可能是不确定值</li>
<li>而 if 语句只能在always里面，所以如果想要在assign中使用判断语句，则只有使用三目运算符来处理，这是则要注意区分，在assign中使用三目运算符，在always中使用 if 语句</li>
</ol>
</li>
</ol>
</li>
<li><p>再次学习KMP算法，不过还有一部分没有完成，等全部完成之后再进行总结</p>
</li>
<li><p>不论上什么课的时候，都可以将电脑放在旁边，将过程中学习的内容记录下来，不是记录所有的学习内容，只记录摘要就好了，没有电脑也应该这样，上课听讲的时候就应该这样，将自己觉得重要的东西记录下来，只记录关键字也可以</p>
</li>
<li><p>完成的任务很不达标，问题出在哪里？</p>
<ol>
<li><p>上午学习算法的时候，由于之前KMP算法掌握的不好，所以要返回去学习KMP算法</p>
<p>收获：</p>
<ol>
<li>学习算法的过程中一定不要只是在脑海中空想，一定要举例子，即使书上没有举例子，自己也要想一些处理</li>
<li>将思考的过程在本子上写下来，不管是过程中遇到的问题还是学习提炼出的结论</li>
</ol>
</li>
<li><p>下午和晚上都在做实验，主要的时间花在了思考指令的具体运行以及实现指令上</p>
<p>收获：</p>
<ol>
<li>当遇到一个问题很久都想不清楚的时候，去请教一下别人，是个很明智的选择</li>
<li>当想明白了每个指令的作用以及具体运行之后，实现就变得十分简单，不论是用自己的方法去实现还是理解书上的实现方法</li>
<li>当遇到书上有不能理解的地方的时候，从指令的根源去思考，指令具体的运行</li>
<li>看书不只是为了实现书上的代码，更多的是想一下与自己写的有什么区别，谁的更好一下，书上的代码有哪些需要改进的地方，自己的代码有哪些需要改进的地方</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="明天：-21"><a href="#明天：-21" class="headerlink" title="明天："></a>明天：</h3><ol>
<li>物理实验估计还是做不了什么东西<ol>
<li>将简单的算术运算完善一下</li>
<li>简单的看一下后面的内容</li>
<li>当然，也可以把KMP算法的内容看完</li>
</ol>
</li>
<li>下午完成算术运算剩下的内容</li>
<li>晚上做一下算法题</li>
</ol>
<hr>
<h1 id="11-12："><a href="#11-12：" class="headerlink" title="11/12："></a>11/12：</h1><h3 id="关键字：一些规则、出现未知的错误、解决问题、新增指令、MIPS中的U"><a href="#关键字：一些规则、出现未知的错误、解决问题、新增指令、MIPS中的U" class="headerlink" title="关键字：一些规则、出现未知的错误、解决问题、新增指令、MIPS中的U"></a>关键字：一些规则、出现未知的错误、解决问题、新增指令、MIPS中的U</h3><h3 id="总结：-21"><a href="#总结：-21" class="headerlink" title="总结："></a>总结：</h3><ol>
<li>一些规则：<ol>
<li>不同流向的数据，在不同的块里面进行处理</li>
<li>尽量减少在cpu顶层设计中的中间线路</li>
<li>将随时会改变的值放到一个单独的块里面进行获取最新值<ol>
<li>就和把读操作放到一个单独的块里面一样</li>
<li>或者说，每一个不同的功能都放到一个不同的块里面</li>
</ol>
</li>
</ol>
</li>
<li>出现未知的错误：<ol>
<li>一般来讲，软件是不会出错的，所以问题多半出现在我的代码上</li>
<li>对比一下我的代码和书上的代码有什么不同</li>
<li>修改一部分不同的地方，查找时什么地方出现了问题</li>
</ol>
</li>
<li>解决问题：<ol>
<li>发现问题：<ol>
<li>先观察指令的顺序，与我预测的是否相同</li>
<li>检查指令的定义是否出现了问题</li>
</ol>
</li>
<li>从源头开始查找，一步一步找下去</li>
<li><strong>之所以不倒着找</strong>：有可能前面出现的问题不止一个，那么到后面越分越多，就会变得越来越难以分辨</li>
<li><strong>当出现多个可能的错误时</strong>：<ol>
<li>控制变量法，使其只有一个变化值</li>
<li>一个一个排除问题</li>
</ol>
</li>
</ol>
</li>
<li>新增指令<ol>
<li>修改id阶段，尽量不新增端口</li>
<li>除了id以及ex，其余阶段目前大多只是起到了传递的作用</li>
</ol>
</li>
<li>MIPS中的U：<ol>
<li>MIPS中的U表示不考虑溢出的情况，比如ADD和ADDU，如果有溢出，那么ADD的结果就不会保存下来</li>
<li>但这并不意味着就不考虑有无符号了，ADD还是表示有符号加法，不过有无符号只在判断溢出的时候会用到，具体计算的时候都是相同的，用补码的方式进行计算，<strong>但是补码却和加法没有关系？</strong></li>
</ol>
</li>
</ol>
<h3 id="明天：-22"><a href="#明天：-22" class="headerlink" title="明天："></a>明天：</h3><ol>
<li>上午第一节课学习算法<ol>
<li>AC自动机</li>
<li>贪心算法</li>
</ol>
</li>
<li>下午：<ol>
<li>完成简单的算术操作</li>
<li>实现流水线暂停机制</li>
</ol>
</li>
<li>晚上：做两道算法题</li>
</ol>
<hr>
<h1 id="11-11："><a href="#11-11：" class="headerlink" title="11/11："></a>11/11：</h1><h3 id="总结：-22"><a href="#总结：-22" class="headerlink" title="总结："></a>总结：</h3><ol>
<li>今天上午在做实验，将该完善的部分完善了，然后就出现了bug，找一下可能会在哪个地方出错</li>
<li>这一天的收获太少了</li>
</ol>
<h3 id="明天：-23"><a href="#明天：-23" class="headerlink" title="明天："></a>明天：</h3><ol>
<li>上午找一下哪个地方出现了错误<ol>
<li>将书上的代码在另一个文件里面实现一下</li>
</ol>
</li>
<li>中午做物理</li>
<li>下午继续做实验，晚上学习算法</li>
</ol>
<hr>
<h1 id="11-09："><a href="#11-09：" class="headerlink" title="11/09："></a>11/09：</h1><h3 id="关键字：lui指令、aluop、查找错误、添加指令"><a href="#关键字：lui指令、aluop、查找错误、添加指令" class="headerlink" title="关键字：lui指令、aluop、查找错误、添加指令"></a>关键字：lui指令、aluop、查找错误、添加指令</h3><h3 id="总结：-23"><a href="#总结：-23" class="headerlink" title="总结："></a>总结：</h3><ol>
<li>lui指令：lui $1,imm<ol>
<li>将立即数赋值给寄存器的高16位</li>
<li>书上也会有不正确的地方，按照自己的想法进行纠正</li>
<li>id中读数据<ol>
<li>如果不能读，则将立即数赋值过去</li>
<li>如果是0号寄存器则赋值为0，这里将id和regfile部分要结合起来看，所以实际上每一个部分都不是独立的存在，要结合输入输出来进行思考</li>
</ol>
</li>
</ol>
</li>
<li>aluop：<ol>
<li>是我自己决定每个的值是什么的</li>
<li>也许有一个固定的规范，比如每一类的指令做一些不同的区别</li>
</ol>
</li>
<li>查找错误：<ol>
<li>如果之前是正确的，那么对比一下改动之后，哪些地方会发生错误</li>
<li>根据指令的流动方向进行检查，看一下是哪一个部分出现了问题</li>
</ol>
</li>
<li>添加指令：<ol>
<li>其实每一类指令对应的操作都是类似的，大多数都是复制粘贴就好了</li>
<li>细节需要注意好</li>
<li>理解每一个指令的含义，对应的输入以及输出</li>
</ol>
</li>
</ol>
<h3 id="明天：-24"><a href="#明天：-24" class="headerlink" title="明天："></a>明天：</h3><ol>
<li>明天上午看一下hpcc的东西，还有问离散的知识</li>
<li>多出来的时间用来看一下接下来要添加的指令</li>
<li>下午做一下离散，或者看一下ASC那边的情况</li>
<li>晚上总结一下这一周，11月的第二周，还有做实验</li>
</ol>
<hr>
<h1 id="11-08："><a href="#11-08：" class="headerlink" title="11/08："></a>11/08：</h1><h3 id="关键字：Makefile、正则表达式，文件读写、焦虑"><a href="#关键字：Makefile、正则表达式，文件读写、焦虑" class="headerlink" title="关键字：Makefile、正则表达式，文件读写、焦虑"></a>关键字：Makefile、正则表达式，文件读写、焦虑</h3><h3 id="总结：-24"><a href="#总结：-24" class="headerlink" title="总结："></a>总结：</h3><ol>
<li><p>Makefile：</p>
<ol>
<li>文件1：文件2，表示目标文件是文件1，源文件是文件2，如果文件1没有的话，就找文件2，文件2也没有就找生成文件2的规则</li>
<li>$<表示源文件， $@表示目标文件</li>
<li>·all：文件3，文件3表示最终要生成的文件</li>
<li>在build里面使用touch之类的生成文件或文件夹</li>
<li>其余的怎样方便怎样进行安排，一般是有一定的规范的，比如CC表示编译，LD表示连接等</li>
</ol>
</li>
<li><p>正则表达式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;regex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> <span class="built_in">line</span>;</span><br><span class="line">    <span class="function">regex <span class="title">pattern</span><span class="params">(<span class="string">":[A-Za-z0-9&#123;8&#125;]"</span>)</span></span>;<span class="comment">//八位的字符串，由字符和数字组成</span></span><br><span class="line">	<span class="built_in">string</span>::const_iterator iterstart = <span class="built_in">line</span>.<span class="built_in">begin</span>();<span class="comment">//迭代器</span></span><br><span class="line">    <span class="built_in">string</span>::const_iterator iterend = <span class="built_in">line</span>.<span class="built_in">end</span>();</span><br><span class="line">    <span class="keyword">while</span> (regex_search(iterstart, iterend, inst_tmp, pattern1))</span><br><span class="line">    &#123;</span><br><span class="line">    	temp1 = inst_tmp[<span class="number">0</span>];</span><br><span class="line">    	<span class="comment">// cout &lt;&lt; temp &lt;&lt; endl;</span></span><br><span class="line">    	iterstart = inst_tmp[<span class="number">0</span>].second;	<span class="comment">//更新搜索起始位置,搜索剩下的字符串</span></span><br><span class="line">    	<span class="built_in">string</span>::const_iterator iterstart1 = temp1.<span class="built_in">begin</span>();</span><br><span class="line">         <span class="built_in">string</span>::const_iterator iterend1 = temp1.<span class="built_in">end</span>();</span><br><span class="line">         <span class="keyword">while</span>(regex_search(iterstart1,iterend1,inst,pattern2))&#123;</span><br><span class="line">          	 temp2 = inst[<span class="number">0</span>];</span><br><span class="line">             <span class="comment">// cout&lt;&lt;temp2&lt;&lt;endl;</span></span><br><span class="line">             iterstart1 = inst[<span class="number">0</span>].second;</span><br><span class="line">             file_write &lt;&lt;temp2 &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>regex有三种方法：<ol>
<li>regex_match()，用来匹配完全相同的字符串</li>
<li>regex_search()，用来匹配满足条件的子串</li>
<li>还有一个我忘了，没用到</li>
</ol>
</li>
</ol>
</li>
<li><p>文件读写：</p>
<ol>
<li><a href="https://blog.csdn.net/stpeace/article/details/12404925" target="_blank" rel="noopener">如何利用C/C++逐行读取txt文件中的字符串(可以顺便实现文本文件的复制)</a></li>
</ol>
</li>
<li><p>焦虑：</p>
<ol>
<li>要做的事情很多，但时间却很少</li>
<li>很多事情是我不想做的，比如去上课</li>
<li>解决方法：将原因找出来，自我对话</li>
</ol>
</li>
</ol>
<hr>
<h1 id="11-07："><a href="#11-07：" class="headerlink" title="11/07："></a>11/07：</h1><h3 id="关键字：Linux的一些操作、虚拟机、GNU工具链、正则表达式"><a href="#关键字：Linux的一些操作、虚拟机、GNU工具链、正则表达式" class="headerlink" title="关键字：Linux的一些操作、虚拟机、GNU工具链、正则表达式"></a>关键字：Linux的一些操作、虚拟机、GNU工具链、正则表达式</h3><h3 id="总结：·"><a href="#总结：·" class="headerlink" title="总结：·"></a>总结：·</h3><ol>
<li><p>Linux的一些操作：</p>
<ol>
<li><p>解压bz2文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -jxvf xxx.tar.bz2</span><br><span class="line">tar --bzip -x -f  slurm-17.11.9-2.tar.bz2	#另一种，看来还是第一种方便啊</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置环境变量：</p>
<p>修改.bashrc的内容，在最后添加：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PATH="$PATH:xxx/xxx/xxxx"</span><br></pre></td></tr></table></figure>
</li>
<li><p>问题：bash：没有那个文件或文件夹：</p>
<p>原因：缺少相应的32位运行库（因为现在都是64位机了）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install ia32-libs</span><br></pre></td></tr></table></figure>

<p>有可能会提示没有这个安装包，安装他提示推荐的安装包就行了</p>
</li>
</ol>
</li>
<li><p>虚拟机：</p>
<ol>
<li><p>安装VMware Tools：</p>
<ol>
<li><p>点击虚拟机的重新安装或者安装VMware Tools，会在桌面出现一个光盘状文件</p>
</li>
<li><p>打开那个文件，将一个压缩包复制到一个文件夹</p>
</li>
<li><p>解压之后进入文件夹，运行一个pl文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*****.pl -d</span><br></pre></td></tr></table></figure>

<p>-d表示都是默认选项，这样就不用一直去点了</p>
</li>
</ol>
</li>
<li><p>与主机共享文件夹：</p>
<ol>
<li>在虚拟机设置中启用共享文件夹的选择（只有在启动虚拟机之后才能选择）</li>
<li>可以在 /mnt 文件夹中找到共享的文件夹</li>
<li>如果共享的文件夹突然消失了：<ol>
<li>将共享文件夹的选项关闭之后重新打开一下</li>
<li>将虚拟机的电源关了重新打开一下</li>
<li>重新安装VMware Tools</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>GNU工具链：</p>
<ol>
<li><p>在按照书上运行时，出现的问题：</p>
<ol>
<li>要将 ram 修改为 ram(wrx) 也就是在指定存储空间时，也要确定存储空间的权限</li>
</ol>
</li>
<li><p>-as 是编译工具</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mips-linux-gnu-as -mips 源文件名 -o 目的文件名</span><br></pre></td></tr></table></figure>
</li>
<li><p>-ld 是链接工具</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mips-linux-gnu-ld -T 链接文件名 源文件名 -o 目的文件名</span><br></pre></td></tr></table></figure>
</li>
<li><p>-objdump 是反编译工具</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mips-linux-gnu-objdump -D 源文件名 &gt; 目的文件名</span><br></pre></td></tr></table></figure>
</li>
<li><p>一顿操作下来，按照自己的需求来进行就行了</p>
</li>
</ol>
</li>
<li><p>Makefile：</p>
<ol>
<li><p>$< 表示第一个依赖文件的名称</p>
</li>
<li><p>$@ 表示目标的完整名称，这两个就是用来进行代替的</p>
</li>
<li><pre><code class="shell">all: 文件名 #文件名表示最后要得到的文件
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">4. ~~~shell</span><br><span class="line">   文件名1 ： 文件名2 #文件名1 表示目的文件($&lt;)，文件名2 表示源文件($@)</span><br></pre></td></tr></table></figure></code></pre>
</li>
<li><p>elf文件，至少我现在是看不懂的，主要是不知道怎么看，全是乱码</p>
</li>
</ol>
</li>
<li><p>正则表达式：</p>
<ol>
<li>匹配数字：\d</li>
<li>匹配n个数字： \d{n}   //{n}表示n个</li>
<li><a href="https://www.cnblogs.com/zxin/archive/2013/01/26/2877765.html" target="_blank" rel="noopener">最全的常用正则表达式大全——包括校验数字、字符、一些特殊的需求等等</a></li>
<li>在c++中使用正则表达式：用一些现成的函数就行了</li>
</ol>
</li>
</ol>
<h3 id="反思："><a href="#反思：" class="headerlink" title="反思："></a>反思：</h3><ol>
<li>没有严格按照计划来进行：<ol>
<li>上午确实是没有时间</li>
<li>下午没有做实验，主要的时间花费在了生成机器语言上</li>
</ol>
</li>
</ol>
<h3 id="明天：-25"><a href="#明天：-25" class="headerlink" title="明天："></a>明天：</h3><ol>
<li>上午第二节课：<ol>
<li>将生成机器语言改成自动化的一个过程</li>
<li>继续完成第五章的内容（至少一半的逻辑指令）</li>
</ol>
</li>
<li>下午第一节课：<ol>
<li>完成离散的作业</li>
<li>学习一下最长子序列的算法（可选）</li>
</ol>
</li>
<li>下午第二节课：<ol>
<li>将第五章的实验做完</li>
</ol>
</li>
<li>晚上：<ol>
<li>了解并完成1/3的第六章的实验</li>
</ol>
</li>
</ol>
<hr>
<h2 id="11-06："><a href="#11-06：" class="headerlink" title="11/06："></a>11/06：</h2><h3 id="关键字：查找错误、指令与指令的分段、trie树、更改端口、怎么制定第二天的计划、最长公共子串、动态规划"><a href="#关键字：查找错误、指令与指令的分段、trie树、更改端口、怎么制定第二天的计划、最长公共子串、动态规划" class="headerlink" title="关键字：查找错误、指令与指令的分段、trie树、更改端口、怎么制定第二天的计划、最长公共子串、动态规划"></a>关键字：查找错误、指令与指令的分段、trie树、更改端口、怎么制定第二天的计划、最长公共子串、动态规划</h3><h3 id="总结：-25"><a href="#总结：-25" class="headerlink" title="总结："></a>总结：</h3><ol>
<li>查找错误：<ol>
<li>从源头开始找，哪个数据出现了问题，这个数据和什么有关系</li>
<li>一点一点追溯问题的根源</li>
</ol>
</li>
<li>指令与指令的分段：<ol>
<li>有时候会有一种错觉就是指令和指令的分段是一一对应的</li>
<li>实际上指令的显示是16进制和，和指令的分段不同</li>
<li>所以要转换为2进制，然后再进行分段</li>
</ol>
</li>
<li>trie树：<ol>
<li>trie树就是将前缀相同的子串放在一起</li>
<li>这个在代码补全等方面有很大的作用</li>
</ol>
</li>
<li>更改端口：<ol>
<li>在添加一些新的指令或者功能之后，有时会忘记在调用的地方更改“参数”的传递</li>
</ol>
</li>
<li>最长公共子串：<ol>
<li>最长公共子串和最长公共子序列都需要用到动态规划的思想</li>
<li>最长公共子串是最长公共子序列的一种特殊情况，只需要加一个限制条件就好了</li>
<li>具体的实现我现在还不了解，接下来这几天就先把这个学习了</li>
</ol>
</li>
<li>动态规划：<ol>
<li>动态规划的思想与分治的思想比较类似，都是将问题划分为一个又一个的子问题</li>
<li>不同的地方是：动态规划会将子问题的结果存入到表中，这样就可以避免重复计算子问题</li>
</ol>
</li>
<li>怎么制定第二天的计划：<ol>
<li>制定计划的时候，更具体一下<ol>
<li>实验：具体实现多少指令或者多少页的内容</li>
<li>算法：看完哪些算法的内容，做多少题，看多少题解</li>
<li>结果并行的知识，我发的那几篇文章都没看过，具体一个时间进行</li>
<li>现在还多了一个挑战杯的内容，这个应该要具体确定选题之后，才能知道怎么做规划</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="明天：-26"><a href="#明天：-26" class="headerlink" title="明天："></a>明天：</h3><ol>
<li>明天上午要做物理实验，不知道完成需要多少时间，所以明天上午多出来的时间看算法的知识吧<ol>
<li>最长子序列以及那道题的题解</li>
</ol>
</li>
<li>明天下午做实验<ol>
<li>实现第五章：逻辑、移位操作以及空指令</li>
</ol>
</li>
<li>晚上上课，上完课之后，规划一下接下来的安排<ol>
<li>复习</li>
<li>完成实验</li>
<li>做PPT，写实验报告</li>
</ol>
</li>
</ol>
<hr>
<h2 id="11-05："><a href="#11-05：" class="headerlink" title="11/05："></a>11/05：</h2><h3 id="关键字：仿真日志、怎么写cpu"><a href="#关键字：仿真日志、怎么写cpu" class="headerlink" title="关键字：仿真日志、怎么写cpu"></a>关键字：仿真日志、怎么写cpu</h3><h3 id="总结：-26"><a href="#总结：-26" class="headerlink" title="总结："></a>总结：</h3><ol>
<li>仿真日志：<ol>
<li>仿真日志还是很重要的，应该把warning解决掉</li>
<li>比如这次warning中提示了端口不匹配的问题，而这个问题直接导致仿真结果与我的预测结果不同</li>
</ol>
</li>
<li>怎么写cpu：<ol>
<li>从最简单的开始：从一条指令开始，使用增量模型，逐渐增加指令，一次考虑过多指令会导致情况变得十分复杂</li>
<li>在编写的过程中，只关注一个部件，默认输入的数据是正确的</li>
</ol>
</li>
</ol>
<h3 id="明天：-27"><a href="#明天：-27" class="headerlink" title="明天："></a>明天：</h3><ol>
<li>第一节课学习算法</li>
<li>下午做实验</li>
<li>晚上做实验</li>
</ol>
<hr>
<h2 id="11-04："><a href="#11-04：" class="headerlink" title="11/04："></a>11/04：</h2><h3 id="关键字：git-cz、eclipse-快捷运行、递归注意、应该怎么做题、尝试用树来做那道题"><a href="#关键字：git-cz、eclipse-快捷运行、递归注意、应该怎么做题、尝试用树来做那道题" class="headerlink" title="关键字：git cz、eclipse 快捷运行、递归注意、应该怎么做题、尝试用树来做那道题"></a>关键字：git cz、eclipse 快捷运行、递归注意、应该怎么做题、尝试用树来做那道题</h3><h3 id="总结：-27"><a href="#总结：-27" class="headerlink" title="总结："></a>总结：</h3><ol>
<li><p>应该怎么做题：</p>
<ol>
<li>考虑的仔细一些，多种不同的情况</li>
<li>多想一下有没有更好的方法</li>
<li>边界情况</li>
</ol>
</li>
<li><p>git cz：</p>
<ol>
<li>不知道为啥就是不能直接用git cz</li>
<li>只能通过  npx git-cz 进行使用</li>
</ol>
</li>
<li><p>eclipse 运行的快捷键：Ctrl + f11</p>
</li>
<li><p>递归注意：</p>
<ol>
<li>在遇到有返回值的时候，注意要将返回值考虑进去，因为递归是有“归”的</li>
<li>如果是boolean类型的，注意进行判断，返回</li>
</ol>
</li>
</ol>
<h3 id="明天：-28"><a href="#明天：-28" class="headerlink" title="明天："></a>明天：</h3><ol>
<li>上午做实验</li>
<li>中午做线代</li>
<li>下午做实验</li>
<li>晚上离散和算法</li>
</ol>
<hr>
<h2 id="11-03："><a href="#11-03：" class="headerlink" title="11/03："></a>11/03：</h2><h3 id="关键字：读写操作、alusel的作用（猜想）、String操作、map、"><a href="#关键字：读写操作、alusel的作用（猜想）、String操作、map、" class="headerlink" title="关键字：读写操作、alusel的作用（猜想）、String操作、map、"></a>关键字：读写操作、alusel的作用（猜想）、String操作、map、</h3><h3 id="总结：-28"><a href="#总结：-28" class="headerlink" title="总结："></a>总结：</h3><ol>
<li><p>读写操作：</p>
<ol>
<li>对regfile或者存储器的读写操作随时都有可能进行，所以要放到一个单独的块里面</li>
<li>根据功能的不同进行分块</li>
</ol>
</li>
<li><p>alusel的作用（猜想）：</p>
<ol>
<li>根据操作类型选择输出结果</li>
<li>我觉得这样做是为之后的并行做准备</li>
<li>这样可以一次对多个指令进行处理（我觉得）</li>
</ol>
</li>
<li><p>String操作：（String s）</p>
<ol>
<li>获取其中一个字符：s.charAt( i )；</li>
<li>获取一段字符：s.substring( i , j )；</li>
<li>分割字符：s.sblit(‘x’)；以“x”作为分割</li>
</ol>
</li>
<li><p>java map：</p>
<ol>
<li><p>如果有重复的值，则会将之前的值覆盖掉</p>
</li>
<li><p>map的遍历方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Integer key:map.keySet())&#123;		<span class="comment">//遍历key</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(Integer valus:map.values())&#123;	<span class="comment">//遍历value</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ol>
<h3 id="明天：-29"><a href="#明天：-29" class="headerlink" title="明天："></a>明天：</h3><ol>
<li>明天上午第一节课做实验</li>
<li>第二节课做线代</li>
<li>下午学习离散和算法知识</li>
<li>晚上做实验</li>
</ol>
<hr>
<h2 id="11-02："><a href="#11-02：" class="headerlink" title="11/02："></a>11/02：</h2><h3 id="关键字：指令、分配、错误、间隔、ALUop、打开方式、清除项目、添加波形图、id"><a href="#关键字：指令、分配、错误、间隔、ALUop、打开方式、清除项目、添加波形图、id" class="headerlink" title="关键字：指令、分配、错误、间隔、ALUop、打开方式、清除项目、添加波形图、id"></a>关键字：指令、分配、错误、间隔、ALUop、打开方式、清除项目、添加波形图、id</h3><h3 id="总结：-29"><a href="#总结：-29" class="headerlink" title="总结："></a>总结：</h3><ol>
<li><p>指令类型</p>
<ol>
<li><p>R型指令：</p>
<table>
<thead>
<tr>
<th align="center">31       26</th>
<th align="center">25     21</th>
<th align="center">20     16</th>
<th align="center">15     11</th>
<th align="center">10     6</th>
<th align="center">5     0</th>
</tr>
</thead>
<tbody><tr>
<td align="center">op</td>
<td align="center">rs</td>
<td align="center">rt</td>
<td align="center">rd</td>
<td align="center">shamt</td>
<td align="center">funct</td>
</tr>
</tbody></table>
<p>其中 rs 和 rt 是源操作寄存器，rd 是目的操作寄存器，也就是存放结果的寄存器，shamt是移位的位数，funct是具体的操作类型，op都是0</p>
</li>
<li><p>I 型指令：</p>
<table>
<thead>
<tr>
<th align="center">31       26</th>
<th align="center">25     21</th>
<th align="center">20     16</th>
<th align="center">15          0</th>
</tr>
</thead>
<tbody><tr>
<td align="center">op</td>
<td align="center">rs</td>
<td align="center">rt</td>
<td align="center">immediate</td>
</tr>
</tbody></table>
<p>将immediate扩展为32位，然后再将其与 rs 进行操作，最后结果存放到 rt 寄存器中，根据 op 决定指令的类型，</p>
</li>
<li><p>J型指令:</p>
<table>
<thead>
<tr>
<th align="center">31       26</th>
<th align="center">25      0</th>
</tr>
</thead>
<tbody><tr>
<td align="center">op</td>
<td align="center">address</td>
</tr>
</tbody></table>
<p>op 有只有两种： J 以及 JAL</p>
</li>
</ol>
</li>
<li><p>分配空间的时候，注意不要分配太大的寄存器，不然会导致无法综合，因为在综合的要找最合适的方案，所以会耗费很多时间，并且很有可能没有结果，可以用整数来替代分频</p>
</li>
<li><p>解决错误：步步为营，现在这个方法就很不错，将问题记录下来，免得自己忘了自己的问题是什么，从而找错了方向，也可以引发自己思考</p>
</li>
<li><p>同上，在思考的时候，将思考的过程以及思考的结果记录下来，会有奇效</p>
</li>
<li><p>设置分频时间：</p>
<ol>
<li>在多个数码管上进行显示：分频20的显示最为稳定</li>
<li>在一个数码管上实现计数器：分频50000000的跳动次数最接近 1s</li>
<li>不知道为什么在外面设置分频会出现错误，其他人也是这样，但是没有问题</li>
</ol>
</li>
<li><p>设置时钟的引脚：不推荐设置其他管脚作为时钟管脚，因为会有很大的延迟，意义也不大</p>
</li>
<li><p>ALUop：其实就是用来在ALU单元中控制操作的，每个指令都有独立的ALUop，所以在 id 中通过 op 来确定指令类型，顺便确定aluop的值</p>
</li>
<li><p>打开方式：什么的打开方式？我给忘了，所以要将问题记录下来，至少要放到另一个文档中记录下来</p>
</li>
<li><p>如何清除项目（清理到初始状态，避免再次创建项目的麻烦）：</p>
<ol>
<li>随便创建一个新的项目，看一下有哪些原来就有的文件夹</li>
<li>将要清理的项目中的文件夹删除到只剩下那些文件夹就行了</li>
</ol>
</li>
<li><p>添加波形图（添加模块的中间寄存器之类的放到波形图中）：</p>
<ol>
<li>先进行仿真</li>
<li>然后将要添加的中间件添加到波形图中，但是这个时候是没有波形的</li>
<li>所以要重新运行一下，是重新运行，而不是重新仿真</li>
<li>如果波形图的时间不够的话，也可以通过运行后续进行添加</li>
</ol>
</li>
<li><p><strong>id</strong>：</p>
<ol>
<li>在<strong>id</strong>中进行的主要操作，就是为接下来的操作做准备，比如提前准备好数据、地址以及使能信号等</li>
<li>从pc中获取地址</li>
<li>用这个地址从regfile中获取指令</li>
<li>对指令进行译码，然后做准备工作</li>
<li>在过程中需要对regfile进行多次读取操作，因为信号以及读取操作是同时进行的，所以要用非阻塞赋值</li>
</ol>
</li>
<li><p>实现CPU：</p>
<ol>
<li>按照部件的每个功能，逐步进行操作</li>
</ol>
</li>
</ol>
<h3 id="明天：-30"><a href="#明天：-30" class="headerlink" title="明天："></a>明天：</h3><ol>
<li>明天上午继续做实验，至少把 id/ex 实现，执行阶段尽量完成</li>
<li>下午写周总结，写文章</li>
<li>晚上有时间的话，做一下算法</li>
</ol>
<hr>
<h2 id="11-01："><a href="#11-01：" class="headerlink" title="11/01："></a>11/01：</h2><h3 id="关键字：重名错误、只用module、KMP算法、思考、怎么写CPU、几个模块的组合"><a href="#关键字：重名错误、只用module、KMP算法、思考、怎么写CPU、几个模块的组合" class="headerlink" title="关键字：重名错误、只用module、KMP算法、思考、怎么写CPU、几个模块的组合"></a>关键字：重名错误、只用module、KMP算法、思考、怎么写CPU、几个模块的组合</h3><h3 id="总结：-30"><a href="#总结：-30" class="headerlink" title="总结："></a>总结：</h3><ol>
<li>重名错误：<ol>
<li>当使用<strong>block design</strong>的时候，有时候模块的名字和design的名字一样，导致模块的顶层变成了重名的那个模块，而不是block design的模块</li>
<li>表现：一个本来应该在design中的模块，出现在了外面，并且design中没有相应的文件</li>
</ol>
</li>
<li>只用module：<ol>
<li>只用module的时候，不用像用ip核一样，生成相应的.v文件，创建wrapper文件就好了</li>
</ol>
</li>
<li>KMP算法：<ol>
<li>KMP算法和BM算法和类似，都用到了前缀与后缀的匹配，其中KMP算法用到的是好前缀规则</li>
<li>这两个算法，最重要的是数据结构：PMT数组，也就是前缀和后缀的交集中，最长的一个</li>
<li>其中KMP算法用到了动态规划的思想，也就是后一种状态只与前一种状态有关，在KMP算法中：<ol>
<li>假设前面一个指针为 j ，后面一个指针为 i</li>
<li>如果 j 和 i 相等，则将 PMT[i] 对应的值设置为 PMT[j]+1，并将 j 和 i 都向后移动一位</li>
<li>如果 j 和 i 不相等，则将 j 移动到PMT[j-1]的位置进行比较，以此类推，如果回到了开头，则将 PMT[i] = 0</li>
</ol>
</li>
</ol>
</li>
<li>思考：<ol>
<li>如果看书或者文章感到困难的话，找个视频来看是个明智的选择</li>
<li>在哔哩哔哩或者YouTube上找视频来看，或者是找一些其他途径</li>
</ol>
</li>
<li>怎么写CPU（学习）：<ol>
<li>在看书、写代码的过程中不断的思考，将遇到的问题记录下来，如果有机会的话拿去问一下</li>
<li>书上有完整的代码，不过不要急着去看，先尝试自己写一下，然后再与书上的代码进行对比<ol>
<li>有哪些我没考虑到的地方</li>
<li>有哪些我觉得比较困难的地方</li>
<li>每个部分需要用到之前学的哪些知识</li>
<li>如何将这个部分与之前写成的部分结合起来</li>
</ol>
</li>
</ol>
</li>
<li>分频器并不能放在外面，因为分频器的输出并不能作为时钟输入，这和下板测试时不能将时钟端口接到其他端口是一样的</li>
</ol>
<h3 id="明天：-31"><a href="#明天：-31" class="headerlink" title="明天："></a>明天：</h3><ol>
<li><p>上午继续做实验，带上板子</p>
</li>
<li><p>下午实验课继续做实验</p>
</li>
<li><p>晚上做一下算法题，或者看一下并行方面接下来应该如何进行</p>
</li>
</ol>
<hr>
<h2 id="10-31："><a href="#10-31：" class="headerlink" title="10/31："></a>10/31：</h2><h3 id="关键字：增量模型、Verilog全局宏定义"><a href="#关键字：增量模型、Verilog全局宏定义" class="headerlink" title="关键字：增量模型、Verilog全局宏定义"></a>关键字：增量模型、Verilog全局宏定义</h3><h3 id="总结：-31"><a href="#总结：-31" class="headerlink" title="总结："></a>总结：</h3><ol>
<li>增量模型：就是从最简单的开始，然后一点点的增加功能等</li>
<li>Verilog全局宏定义：暂时还不知道</li>
<li>今天确实没做什么事情，上午实验课啥也没做，下午在408也没做成什么事情，晚上一直在上课</li>
</ol>
<h3 id="明天：-32"><a href="#明天：-32" class="headerlink" title="明天："></a>明天：</h3><ol>
<li>上午继续下板实验</li>
<li>下午第一节课学离散和算法</li>
<li>下午第二节课做实验</li>
<li>晚上做算法题</li>
</ol>
<hr>
<h2 id="10-30："><a href="#10-30：" class="headerlink" title="10/30："></a>10/30：</h2><h3 id="关键字：补码、有符号数加法、各种溢出判断、解压rar、按位取反、任务、函数"><a href="#关键字：补码、有符号数加法、各种溢出判断、解压rar、按位取反、任务、函数" class="headerlink" title="关键字：补码、有符号数加法、各种溢出判断、解压rar、按位取反、任务、函数"></a>关键字：补码、有符号数加法、各种溢出判断、解压rar、按位取反、任务、函数</h3><h3 id="总结：-32"><a href="#总结：-32" class="headerlink" title="总结："></a>总结：</h3><ol>
<li><p>补码：</p>
<ol>
<li>正数的补码、反码、原码都一样，这是由规定决定的，而不是计算得出的</li>
<li>所以如果结果是正数，那么就不用将其进行-1取反的操作了</li>
<li>符号位不变，其余的按位取反，末位加1</li>
</ol>
</li>
<li><p>各种溢出判断：</p>
<ol>
<li>无符号数加法：结果比减数或者被减数小</li>
<li>无符号数减法：被减数小于减数</li>
<li>有符号数加法：<ol>
<li>同为正数或者同为负数才会溢出</li>
<li>结果的符号位于原数的符号位不用则表示溢出了</li>
</ol>
</li>
<li>有符号数减法：转换为加法就行了</li>
</ol>
</li>
<li><p>解压rar：通过使用</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rar x xxx.rar</span><br></pre></td></tr></table></figure>
</li>
<li><p>按位取反：</p>
<ol>
<li>使用“！”不能直接对一个数按位取反，得到的是一个只有一位的数，0或者1</li>
<li>所以打算写一个任务或者函数来完成类似的功能</li>
</ol>
</li>
<li><p>任务：</p>
<ol>
<li><p>定义：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> hello;</span><br><span class="line">    <span class="keyword">input</span> a,b;</span><br><span class="line">    <span class="keyword">output</span> c;</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        c=a+b;<span class="comment">//除了端口，其余的要放到块中</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endtask</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
</li>
</ol>
<ol start="2">
<li><p>调用：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello(x,y,z);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<ol start="6">
<li><p>函数：</p>
<ol>
<li><p>定义：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> [WIDTH-<span class="number">1</span>:<span class="number">0</span>] Negation;<span class="comment">//按位取反,Negation 就是输出（也就是返回值）</span></span><br><span class="line">        <span class="keyword">input</span> [WIDTH-<span class="number">1</span>:<span class="number">0</span>] num;</span><br><span class="line">        <span class="keyword">integer</span> i;</span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;WIDTH-<span class="number">2</span>;i=i+<span class="number">1</span>)<span class="comment">//最高位不变</span></span><br><span class="line">            num[i]=~num[i];</span><br><span class="line">        Negation=num;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endfunction</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
</li>
</ol>
<ol start="2">
<li><p>调用：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Negation(data_in_1);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="明天：-33"><a href="#明天：-33" class="headerlink" title="明天："></a>明天：</h3><ol>
<li>明天上午做物理实验，以及并行（或者算法）</li>
<li>下午看书做实验</li>
<li>晚上是不会有时间的，可以看一下算法</li>
</ol>
<hr>
<h2 id="10-28："><a href="#10-28：" class="headerlink" title="10/28："></a>10/28：</h2><h3 id="关键字：溢出判断、"><a href="#关键字：溢出判断、" class="headerlink" title="关键字：溢出判断、"></a>关键字：溢出判断、</h3><h3 id="总结：-33"><a href="#总结：-33" class="headerlink" title="总结："></a>总结：</h3><ol>
<li>上午啥也没干，原因：1.起床晚，2.物理课上让写论文</li>
<li>下午啥也没干，原因：1.游泳课，2.玩游戏</li>
<li>晚上也没干啥，原因：1.看了两个小时的电影</li>
<li>不过也做了点，将alu进行了完善，不过没有进行测试，情况太多了，具体下板进行测试吧</li>
<li>反思一下：不要主动向别人要一些小东西，也不要主动给一些人东西</li>
</ol>
<h3 id="明天：-34"><a href="#明天：-34" class="headerlink" title="明天："></a>明天：</h3><ol>
<li>明天上午玩游戏</li>
<li>下午进行下板测试</li>
<li>晚上离散和算法</li>
</ol>
<hr>
<h2 id="10-27："><a href="#10-27：" class="headerlink" title="10/27："></a>10/27：</h2><h2 id="明天：-35"><a href="#明天：-35" class="headerlink" title="明天："></a>明天：</h2><ol>
<li>明天上午把6.8和6.9做完</li>
<li>下午离散和算法</li>
<li>晚上看ASC相关的</li>
</ol>
<hr>
<h2 id="10-26："><a href="#10-26：" class="headerlink" title="10/26："></a>10/26：</h2><h3 id="关键字：仿真输出总是不变、写入文件、存储器"><a href="#关键字：仿真输出总是不变、写入文件、存储器" class="headerlink" title="关键字：仿真输出总是不变、写入文件、存储器"></a>关键字：仿真输出总是不变、写入文件、存储器</h3><h3 id="思考："><a href="#思考：" class="headerlink" title="思考："></a>思考：</h3><ol>
<li>如果可以通过文件来写入存储器，那么操作系统就可以通过现在外面编译出可执行文件，然后再将其烧到板子上了，不过编译过程中好像是动态链接的</li>
<li>算法还是要做的，不过如果和ASC的时间冲突的话，就没办法去集训了</li>
</ol>
<h3 id="总结：-34"><a href="#总结：-34" class="headerlink" title="总结："></a>总结：</h3><ol>
<li><p>上午在做实验</p>
</li>
<li><p>下午居然什么都没做，不过解决了问题</p>
</li>
<li><p>在时序总最好用非阻塞赋值语句</p>
</li>
<li><p>晚上开了个会，也什么都没做</p>
</li>
<li><pre><code class="verilog">写入文件的方法：   <span class="built_in">$fdisplay</span>(handle,<span class="string">"%d"</span>,rand_num);<span class="comment">//写数据，handle是打开文件的，类似于指针？</span>
<span class="keyword">integer</span> handle;<span class="comment">//定义后面要用到的变量</span>
<span class="comment">//...</span>
<span class="comment">//...</span>

handle = <span class="built_in">$fopen</span>(<span class="string">"data.txt"</span>);<span class="comment">//打开文件</span>
<span class="comment">//...</span>
<span class="comment">//...</span>
<span class="keyword">always</span> #<span class="number">10</span> clk = ~clk;<span class="comment">//定义时钟</span>
<span class="keyword">always</span> #<span class="number">20</span>
<span class="keyword">begin</span>
    <span class="built_in">$fdisplay</span>(handle,<span class="string">"%d"</span>,rand_num);<span class="comment">//写数据</span>
    <span class="keyword">while</span>(!rst_n) <span class="built_in">$fclose</span>(handle);<span class="comment">//关文件</span>
<span class="keyword">end</span>
&lt;!--￼<span class="number">103</span>--&gt;
   upgrade_ip [get_ips xxx]
   &lt;!--￼<span class="number">104</span>--&gt;

还有就是，要将自己遇到的问题都记录下来，这样在以后再次遇到的时候，就能够快速的解决了，今天下午遇到了一个问题然我觉得很熟悉，觉得是我之前遇到过，但是想不起来了，现在也想不起来是什么问题了</code></pre>
</li>
<li><p>看了一些二叉树的内容，主要是关于完全二叉树的，完全二叉树是什么呢？完全二叉树就是全部都是完整的，只有都偏向于左边的</p>
</li>
<li><p>上午我在宿舍干了什么呢？感觉像是什么都没干，上午在宿舍做了一下那个实验，还行</p>
</li>
<li><p>然后就是晚上上课了，晚上上课学了什么呢？</p>
<p>算术比较、乘法之类的</p>
</li>
<li><p>还有就是指令级并行相关的内容</p>
</li>
</ol>
<h3 id="明天：-36"><a href="#明天：-36" class="headerlink" title="明天："></a>明天：</h3><ol>
<li>明天上午第一节课的时间，把实验下板试一下，重点是看那两个方法中的哪一个行得通</li>
<li>线性代数课的时候，把上次布置的作业做一下，我寻思着要不在下午上离散课的时候再做作业，毕竟离散课的时候是不能看电脑的，看情况，如果离散没有作业的话，就做线代</li>
<li>晚上做实验，其他时候就看书</li>
</ol>
<p>英语课是我用来学数据结构了，主要是学了散列表以及哈希算法，其中哈希算法讲的是哈希算法在实际工程中的应用，主要有三个用途，一是加密，二是存储信息，三是在分布式中的运用。散列表中呢，则是散列表与链表的综合，其中难以理解的散列表和双向链表的结合，其实散列表讲究的就是一一对应，哈希函数。而在散列表中呢，要注意的是解决散列冲突，</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%97%A0/" rel="tag"># 无</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item"></div>
      <div class="post-nav-item">
    <a href="/2020/03/23/hello-world/" rel="next" title="Hello World">
      Hello World <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#05-16"><span class="nav-number">1.</span> <span class="nav-text">05&#x2F;16:</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#关键字：单链表反转、查找Spring的配置、ORM、Android软键盘的显示与隐藏、工厂策略、加快IDEA导入包的速度、控制反转、好用的作图网站、学习设计模式、DI与IoC、使用Spring创建对象、使用ApplicationContext获取对象、Spring的三种装配Bean的方式、Spring-Bean的手动装配、Spring-Bean的自动装配、注解、使用Java配置Spring-Bean、marginBottom和marginRight设置之后无效、代理模式、alpha、撤销commit、git-pull"><span class="nav-number">1.0.1.</span> <span class="nav-text">关键字：单链表反转、查找Spring的配置、ORM、Android软键盘的显示与隐藏、工厂策略、加快IDEA导入包的速度、控制反转、好用的作图网站、学习设计模式、DI与IoC、使用Spring创建对象、使用ApplicationContext获取对象、Spring的三种装配Bean的方式、Spring Bean的手动装配、Spring Bean的自动装配、注解、使用Java配置Spring Bean、marginBottom和marginRight设置之后无效、代理模式、alpha、撤销commit、git pull</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#05-12"><span class="nav-number">2.</span> <span class="nav-text">05&#x2F;12:</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#关键字：工厂模式、Spring-Dao中的一般操作、Spring-bean、持久层、业务层、控制反转、三种注入方式、反射、哑节点、leetcode会保存全局变量的值、汇编中的立即数、汇编的乘除法、汇编打断点、汇编器的使用方式、Android，animator动画的使用"><span class="nav-number">2.0.1.</span> <span class="nav-text">关键字：工厂模式、Spring Dao中的一般操作、Spring bean、持久层、业务层、控制反转、三种注入方式、反射、哑节点、leetcode会保存全局变量的值、汇编中的立即数、汇编的乘除法、汇编打断点、汇编器的使用方式、Android，animator动画的使用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#04-26"><span class="nav-number">3.</span> <span class="nav-text">04&#x2F;26:</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#关键字：启动Android模拟器出错、Android-让图片不拉伸的方法"><span class="nav-number">3.0.1.</span> <span class="nav-text">关键字：启动Android模拟器出错、Android 让图片不拉伸的方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#04-18"><span class="nav-number">4.</span> <span class="nav-text">04&#x2F;18:</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#超算有延期了，不过有段时间没有做了"><span class="nav-number">4.0.1.</span> <span class="nav-text">超算有延期了，不过有段时间没有做了</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关键字：Git从暂存区恢复、避免每次提交都输入用户和密码、使用git-cz出现错误、进程的内存空间、程序计数器、实现进程、进程与线程、进程间通信（三方面内容）、解决依赖的方法、实现临界区的一些方法、使用hex上传的方法、LeetCode正则表达式匹配的-回溯算法-、git协同工作的一般步骤"><span class="nav-number">4.0.2.</span> <span class="nav-text">关键字：Git从暂存区恢复、避免每次提交都输入用户和密码、使用git-cz出现错误、进程的内存空间、程序计数器、实现进程、进程与线程、进程间通信（三方面内容）、解决依赖的方法、实现临界区的一些方法、使用hex上传的方法、LeetCode正则表达式匹配的&#x3D;&#x3D;回溯算法&#x3D;&#x3D;、git协同工作的一般步骤</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#04-11"><span class="nav-number">5.</span> <span class="nav-text">04&#x2F;11:</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#昨天结束了超算，感觉就像早就结束了"><span class="nav-number">5.0.1.</span> <span class="nav-text">昨天结束了超算，感觉就像早就结束了</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关键字：微信小程序边距控制"><span class="nav-number">5.0.2.</span> <span class="nav-text">关键字：微信小程序边距控制</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#04-02"><span class="nav-number">6.</span> <span class="nav-text">04&#x2F;02:</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#第85天：无"><span class="nav-number">6.0.1.</span> <span class="nav-text">第85天：无</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关键字："><span class="nav-number">6.0.2.</span> <span class="nav-text">关键字：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#04-01"><span class="nav-number">7.</span> <span class="nav-text">04&#x2F;01:</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#第84天：无"><span class="nav-number">7.0.1.</span> <span class="nav-text">第84天：无</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关键字：使用redis的方法、查询redis服务器中的数据、改进redis、在js中获取id、安装android-sdk、做项目的步骤、SQL的好工具、空元素标签、换行、属性、样式、创建链接、内敛元素、在块中使用相同的样式、同一浏览器中显示多个页面、使用JS"><span class="nav-number">7.0.2.</span> <span class="nav-text">关键字：使用redis的方法、查询redis服务器中的数据、改进redis、在js中获取id、安装android sdk、做项目的步骤、SQL的好工具、空元素标签、换行、属性、样式、创建链接、内敛元素、在块中使用相同的样式、同一浏览器中显示多个页面、使用JS</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Pipepw"
      src="/uploads/avatar.png">
  <p class="site-author-name" itemprop="name">Pipepw</p>
  <div class="site-description" itemprop="description">朝乾夕惕</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">6</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/pipepw" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;pipepw" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/pipepw@126.com" title="E-Mail → pipepw@126.com"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Pipepw</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '',
      clientSecret: 'e985df9d24833118c9035abb2b5252f3f0824758',
      repo        : 'Pipepw.github.io',
      owner       : '',
      admin       : ['pipepw'],
      id          : 'd6c73101440ac4baf9f88b0c45ce2b60',
        language: '',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

</body>
</html>
